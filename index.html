<html>
<title>inputs</title>
<style>
h1, h2, h3, h4, h5, h6 { margin-bottom: 1rem; }
h6 { font-size: 1rem; }
h5 { font-size: 2rem; }
h4 { font-size: 4rem; }
h3 { font-size: 8rem; }
h2 { font-size: 16rem; }
h1 { font-size: 32rem; }
</style>
<body>

<h1>inputs</h1>

<h3>bundle.js</h3>
        <pre>import &quot;./src/style.css&quot;;
export {version} from &quot;./package.json&quot;;
export * from &quot;./src/index.js&quot;;
</pre>,<h3>DEVELOPMENT.md</h3>
        <pre># Observable Inputs - Development

To develop Observable Inputs, clone this repository and install its dependencies:

```
git clone git@github.com:observablehq/inputs.git
cd inputs
yarn
```

Inputs is written in ES modules and uses [Snowpack](https://snowpack.dev/) for development; this means that you can edit the Inputs source code and examples, and they’ll update live as you save changes. To start, copy over the example scratch.html file:

```
mkdir scratch
cp test/scratch.html scratch/index.html
```

Then start Snowpack:

```
yarn dev
```

Now you can edit scratch/index.html to see your changes.

To run the tests:

```
yarn test
```

Inputs has both unit tests and snapshot tests. To generate new snapshots, simply delete the current snapshots and then run the tests.

```
rm -rf test/output
yarn test
```
</pre>,<h3>LICENSE</h3>
        <pre>Copyright 2021 Observable, Inc.

Permission to use, copy, modify, and/or distribute this software for any purpose
with or without fee is hereby granted, provided that the above copyright notice
and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.
</pre>,<h3>package.json</h3>
        <pre>{
  &quot;name&quot;: &quot;@observablehq/inputs&quot;,
  &quot;description&quot;: &quot;User interface components for Observable notebooks&quot;,
  &quot;version&quot;: &quot;0.10.6&quot;,
  &quot;author&quot;: {
    &quot;name&quot;: &quot;Observable, Inc.&quot;,
    &quot;url&quot;: &quot;https://observablehq.com&quot;
  },
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;type&quot;: &quot;module&quot;,
  &quot;main&quot;: &quot;src/index.js&quot;,
  &quot;module&quot;: &quot;src/index.js&quot;,
  &quot;jsdelivr&quot;: &quot;dist/inputs.min.js&quot;,
  &quot;unpkg&quot;: &quot;dist/inputs.min.js&quot;,
  &quot;exports&quot;: {
    &quot;umd&quot;: &quot;./dist/inputs.min.js&quot;,
    &quot;default&quot;: &quot;./src/index.js&quot;
  },
  &quot;repository&quot;: {
    &quot;type&quot;: &quot;git&quot;,
    &quot;url&quot;: &quot;https://github.com/observablehq/inputs.git&quot;
  },
  &quot;files&quot;: [
    &quot;dist/**/*.js&quot;,
    &quot;src/**/*.js&quot;
  ],
  &quot;engines&quot;: {
    &quot;node&quot;: &quot;&gt;=14.5.0&quot;
  },
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;mkdir -p test/output &amp;&amp; mocha -r module-alias/register &apos;test/**/*-test.js&apos; test/input.js &amp;&amp; eslint src test&quot;,
    &quot;prepublishOnly&quot;: &quot;rm -rf dist &amp;&amp; rollup -c&quot;,
    &quot;postpublish&quot;: &quot;git push &amp;&amp; git push --tags&quot;,
    &quot;dev&quot;: &quot;snowpack dev&quot;
  },
  &quot;_moduleAliases&quot;: {
    &quot;@observablehq/inputs&quot;: &quot;./src/index.js&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;@rollup/plugin-json&quot;: &quot;4&quot;,
    &quot;@rollup/plugin-node-resolve&quot;: &quot;13&quot;,
    &quot;@rollup/plugin-replace&quot;: &quot;3&quot;,
    &quot;clean-css&quot;: &quot;5&quot;,
    &quot;d3&quot;: &quot;7&quot;,
    &quot;eslint&quot;: &quot;8&quot;,
    &quot;js-beautify&quot;: &quot;1&quot;,
    &quot;jsdom&quot;: &quot;19&quot;,
    &quot;jsesc&quot;: &quot;3&quot;,
    &quot;mocha&quot;: &quot;9&quot;,
    &quot;module-alias&quot;: &quot;2&quot;,
    &quot;rollup&quot;: &quot;2&quot;,
    &quot;rollup-plugin-terser&quot;: &quot;7&quot;,
    &quot;snowpack&quot;: &quot;3&quot;
  },
  &quot;dependencies&quot;: {
    &quot;htl&quot;: &quot;0.3&quot;,
    &quot;isoformat&quot;: &quot;^0.2.0&quot;
  },
  &quot;publishConfig&quot;: {
    &quot;access&quot;: &quot;public&quot;
  }
}
</pre>,<h3>README.md</h3>
        <pre># Observable Inputs

**Observable Inputs** are lightweight user interface components — buttons, sliders, dropdowns, tables, and the like — to help you explore data and build interactive displays in [Observable notebooks](https://observablehq.com). Each input can be used as an [Observable view](https://observablehq.com/@observablehq/introduction-to-views). For example, to allow a number *x* to be manipulated by a slider:

```js
viewof x = Inputs.range([0, 100])
```

Now you can reference the live value of *x* in any cell, *e.g.*:

```js
md`The value of *x* is ${x}.`
```

Any cell that references *x* will run automatically when the *viewof x* slider is moved. For live examples, see:

https://observablehq.com/@observablehq/inputs

Observable Inputs provides basic inputs:

* [Button](#Button) - do something when a button is clicked
* [Checkbox](#Checkbox) - choose any from a set
* [Toggle](#Toggle) - toggle between two values (on or off)
* [Radio](#Radio) - choose one from a set
* [Range](#Range) - choose a numeric value in a range (slider)
* [Select](#Select) - choose one or many from a set (drop-down menu)
* [Text](#Text) - freeform single-line text input
* [Textarea](#Textarea) - freeform multi-line text input
* [Date](#Date) - date input
* [File](#File) - local file input

Observable Inputs provides fancy inputs for tabular data:

* [Search](#Search) - query a tabular dataset
* [Table](#Table) - browse a tabular dataset

Lastly, Inputs provides low-level utilities for more advanced usage:

* [Form](#inputsforminputs-options) - combine multiple inputs
* [Input](#inputsinputvalue) - a programmatic interface for storing input state
* [bind](#inputsbindtarget-source-invalidation) - synchronize two or more inputs
* [disposal](#inputsdisposalelement) - detect when an input is discarded

Observable Inputs are released under the [ISC license](./LICENSE) and depend only on [Hypertext Literal](https://github.com/observablehq/htl), our tagged template literal for safely generating dynamic HTML.

## Inputs

### Button

#### Inputs.button(*content*, *options*)

[&lt;img src=&quot;./img/button.png&quot; alt=&quot;A Button labeled OK&quot; width=&quot;640&quot;&gt;](https://observablehq.com/@observablehq/input-button)

```js
viewof clicks = Inputs.button(&quot;OK&quot;, {label: &quot;Click me&quot;})
```

[Source](./src/button.js) · [Examples](https://observablehq.com/@observablehq/input-button) · A Button emits an *input* event when you click it. Buttons may be used to trigger the evaluation of cells, say to restart an animation. The given *content*, either a string or an HTML element, is displayed within the button. If *content* is not specified, it defaults to “≡”, but a more meaningful value is strongly encouraged for usability.

By default, the value of a solitary Button (when *content* is a string or HTML) is how many times it has been clicked. The *reduce* function allows you to compute the new value of the Button when clicked, given the old value. For example, to set the value as the time of last click:

```js
viewof time = Inputs.button(&quot;Refresh&quot;, {value: null, reduce: () =&gt; Date.now()})
```

If *content* is an array or iterable, then multiple buttons will be generated. Each element in *content* should be a tuple [*contenti*, *reducei*], where *contenti* is the content for the given button (a string or HTML), and *reducei* is the function to call when that button is clicked. For example, to have a counter that you can increment, decrement, or reset to zero:

```js
viewof counter = Inputs.button([
  [&quot;Increment&quot;, value =&gt; value + 1],
  [&quot;Decrement&quot;, value =&gt; value - 1],
  [&quot;Reset&quot;, () =&gt; 0]
], {label: &quot;Counter&quot;, value: 0})
```

The available *options* are:

* *label* - a label; either a string or an HTML element.
* *required* - if true, the initial value defaults to undefined.
* *value* - the initial value; defaults to 0 or null if *required* is false.
* *reduce* - a function to update the value on click; by default returns *value* + 1.
* *width* - the width of the input (not including the label).
* *disabled* - whether input is disabled; defaults to false.

### Checkbox

#### Inputs.checkbox(*data*, *options*)

[&lt;img src=&quot;./img/checkbox.png&quot; alt=&quot;A multi-choice Checkbox input of flavors&quot; width=&quot;640&quot;&gt;](https://observablehq.com/@observablehq/input-checkbox)

```js
viewof flavor = Inputs.checkbox([&quot;Salty&quot;, &quot;Spicy&quot;, &quot;Sour&quot;, &quot;Umami&quot;], {label: &quot;Flavor&quot;})
```

[Source](./src/checkbox.js) · [Examples](https://observablehq.com/@observablehq/input-checkbox) · A Checkbox allows the user to choose any of a given set of values (any of the given elements in the iterable *data*). Unlike a [Select](#Select), a Checkbox’s choices are all visible up-front. The Checkbox’s value is an array of the elements from *data* that are currently selected.

The elements in *data* need not be strings; they can be anything. To customize display, optional *keyof* and *valueof* functions may be given; the result of the *keyof* function for each element in *data* is displayed to the user, while the result of the *valueof* function is exposed in the Checkbox’s value when selected. If *data* is a Map, the *keyof* function defaults to the map entry’s key (`([key]) =&gt; key`) and the *valueof* function defaults to the map entry’s value (`([, value]) =&gt; value`); otherwise, both *keyof* and *valueof* default to the identity function (`d =&gt; d`). For example, with [d3.group](https://github.com/d3/d3-array/blob/master/README.md#group):

```js
viewof sportAthletes = Inputs.checkbox(d3.group(athletes, d =&gt; d.sport))
```

Keys may be sorted and uniqued via the *sort* and *unique* options, respectively. Elements in *data* are formatted via an optional *format* function which has the same defaults as *keyof*. As with the *label* option, the *format* function may return either a string or an HTML element.

The available *options* are:

* *label* - a label; either a string or an HTML element.
* *sort* - true, “ascending”, “descending”, or a comparator function to sort keys; defaults to false.
* *unique* - true to only show unique keys; defaults to false.
* *locale* - the current locale; defaults to English.
* *format* - a format function; defaults to [formatLocaleAuto](#formatLocaleAuto) composed with *keyof*.
* *keyof* - a function to return the key for the given element in *data*.
* *valueof* - a function to return the value of the given element in *data*.
* *value* - the initial value, an array; defaults to an empty array (no selection).
* *disabled* - whether input is disabled, or the disabled values; defaults to false.

### Toggle

#### Inputs.toggle(*options*)

```js
viewof mute = Inputs.toggle({label: &quot;Mute&quot;})
```

[Source](./src/checkbox.js) · [Examples](https://observablehq.com/@observablehq/input-toggle) · A Toggle is a solitary checkbox. By default, the Toggle’s value is whether the checkbox is checked (true or false); a *values* = [*on*, *off*] option can be specified to toggle between two arbitrary values.

The available *options* are:

* *label* - a label; either a string or an HTML element.
* *values* - the two values to toggle between; defaults to [true, false].
* *value* - the initial value; defaults to the second value (false).
* *disabled* - whether input is disabled; defaults to false.

### Radio

#### Inputs.radio(*data*, *options*)

[&lt;img src=&quot;./img/radio.png&quot; alt=&quot;A single-choice Radio input of colors&quot; width=&quot;640&quot;&gt;](https://observablehq.com/@observablehq/input-radio)

```js
viewof color = Inputs.radio([&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;], {label: &quot;Color&quot;})
```

[Source](./src/checkbox.js) · [Examples](https://observablehq.com/@observablehq/input-radio) · A Radio allows the user to choose one of a given set of values. Unlike a [Select](#Select), a Radio’s choices are all visible up-front. The Radio’s value is an element from *data*, or null if no choice has been made.

The elements in *data* need not be strings; they can be anything. To customize display, optional *keyof* and *valueof* functions may be given; the result of the *keyof* function for each element in *data* is displayed to the user, while the result of the *valueof* function is exposed as the Radio’s value when selected. If *data* is a Map, the *keyof* function defaults to the map entry’s key (`([key]) =&gt; key`) and the *valueof* function defaults to the map entry’s value (`([, value]) =&gt; value`); otherwise, both *keyof* and *valueof* default to the identity function (`d =&gt; d`). For example, with [d3.group](https://github.com/d3/d3-array/blob/master/README.md#group):

```js
viewof sportAthletes = Inputs.radio(d3.group(athletes, d =&gt; d.sport))
```

Keys may be sorted and uniqued via the *sort* and *unique* options, respectively. Elements in *data* are formatted via an optional *format* function which has the same defaults as *keyof*. As with the *label* option, the *format* function may return either a string or an HTML element.

The available *options* are:

* *label* - a label; either a string or an HTML element.
* *sort* - true, “ascending”, “descending”, or a comparator function to sort keys; defaults to false.
* *unique* - true to only show unique keys; defaults to false.
* *locale* - the current locale; defaults to English.
* *format* - a format function; defaults to [formatLocaleAuto](#formatLocaleAuto) composed with *keyof*.
* *keyof* - a function to return the key for the given element in *data*.
* *valueof* - a function to return the value of the given element in *data*.
* *value* - the initial value; defaults to null (no selection).
* *disabled* - whether input is disabled, or the disabled values; defaults to false.

### Range

#### Inputs.range(*extent*, *options*)

[&lt;img src=&quot;./img/range.png&quot; alt=&quot;A Range input of intensity, a number between 0 and 100&quot; width=&quot;640&quot;&gt;](https://observablehq.com/@observablehq/input-range)

```js
viewof intensity = Inputs.range([0, 100], {step: 1, label: &quot;Intensity&quot;})
```

[Source](./src/range.js) · [Examples](https://observablehq.com/@observablehq/input-range) · A Range input specifies a number between the given *extent* = [*min*, *max*] (inclusive). If an *extent* is not specified, it defaults to [0, 1]. The chosen number can be adjusted roughly with a slider, or precisely by typing a number.

The available *options* are:

* *label* - a label; either a string or an HTML element.
* *step* - the step (precision); the interval between adjacent values.
* *format* - a format function; defaults to [formatTrim](#formatTrim).
* *placeholder* - a placeholder string for when the input is empty.
* *transform* - an optional non-linear transform.
* *invert* - the inverse transform.
* *validate* - a function to check whether the number input is valid.
* *value* - the initial value; defaults to (*min* + *max*) / 2.
* *width* - the width of the input (not including the label).
* *disabled* - whether input is disabled; defaults to false.

The given *value* is clamped to the given extent, and rounded if *step* is defined. However, note that the *min*, *max* and *step* options affect only the slider behavior, the number input’s buttons, and whether the browser shows a warning if a typed number is invalid; they do not constrain the typed number.

If *validate* is not defined, [*number*.checkValidity](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#dom-cva-checkvalidity) is used. While the input is not considered valid, changes to the input will not be reported.

The *format* function should return a string value that is compatible with native number parsing. Hence, the default [formatTrim](#formatTrim) is recommended.

If a *transform* function is specified, an inverse transform function *invert* is strongly recommended. If *invert* is not provided, the Range will fallback to Newton’s method, but this may be slow or inaccurate. Passing Math.sqrt, Math.log, or Math.exp as a *transform* will automatically supply the corresponding *invert*. If *min* is greater than *max*, *i.e.* if the extent is inverted, then *transform* and *invert* will default to `value =&gt; -value`.

#### Inputs.number([*extent*, ]*options*)

Equivalent to Inputs.range, except the range input is suppressed; only a number input is shown. If only *options* are specified, the *extent* defaults to [-Infinity, Infinity].

### Search

#### Inputs.search(*data*, *options*)

[&lt;img src=&quot;./img/search.png&quot; alt=&quot;A Search input over a tabular dataset of athletes&quot; width=&quot;640&quot;&gt;](https://observablehq.com/@observablehq/input-search)

```js
viewof foundAthletes = Inputs.search(athletes, {label: &quot;Athletes&quot;})
```

[Source](./src/search.js) · [Examples](https://observablehq.com/@observablehq/input-search) · A Search input allows freeform, full-text search of an in-memory tabular dataset or an iterable (column) of values using a simple query parser. It is often used in conjunction with a [Table](#Table). The value of a Search is an array of elements from the iterable *data* that match the current query. If the query is currently empty, the search input’s value is all elements in *data*.

A Search input can work with either tabular data (an array of objects) or a single column (an array of strings). When searching tabular input, all properties on each object in *data* are searched by default, but you can limit the search to a specific set of properties using the *column* option. For example, to only search the “sport” and “nationality” column:

```js
viewof foundAthletes = Inputs.search(athletes, {label: &quot;Athletes&quot;, columns: [&quot;sport&quot;, &quot;nationality&quot;]})
```

For example, to search U.S. state names:

```js
viewof state = Inputs.search([&quot;Alabama&quot;, &quot;Alaska&quot;, &quot;Arizona&quot;, &quot;Arkansas&quot;, &quot;California&quot;, …], {label: &quot;State&quot;})
```

The available *options* are:

* *label* - a label; either a string or an HTML element.
* *query* - the initial search terms; defaults to the empty string.
* *placeholder* - a placeholder string for when the query is empty.
* *columns* - an array of columns to search; defaults to *data*.columns.
* *locale* - the current locale; defaults to English.
* *format* - a function to show the number of results.
* *spellcheck* - whether to activate the browser’s spell-checker.
* *autocomplete* - the [autocomplete](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete) attribute, as text or boolean (true for on, false for off).
* *autocapitalize* - the [autocapitalize](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/autocapitalize) attribute, as text or boolean (true for on, false for off).
* *filter* - the filter factory: a function that receives the query and returns a filter.
* *width* - the width of the input (not including the label).
* *datalist* - an iterable of suggested values.
* *disabled* - whether input is disabled; defaults to false.
* *required* - if true, the search’s value is all *data* if no query; defaults to true.

If a *filter* function is specified, it is invoked whenever the query changes; the function it returns is then passed each element from *data*, along with its zero-based index, and should return a truthy value if the given element matches the query. The default filter splits the current query into space-separated tokens and checks that each token matches the beginning of at least one string in the data’s columns, case-insensitive. For example, the query [hello world] will match the string “Worldwide Hello Services” but not “hello”.

### Select

#### Inputs.select(*data*, *options*)

[&lt;img src=&quot;./img/select.png&quot; alt=&quot;A Select input asking to choose a t-shirt size&quot; width=&quot;640&quot;&gt;](https://observablehq.com/@observablehq/input-select)

```js
viewof size = Inputs.select([&quot;Small&quot;, &quot;Medium&quot;, &quot;Large&quot;], {label: &quot;Size&quot;})
```
```js
viewof inks = Inputs.select([&quot;cyan&quot;, &quot;magenta&quot;, &quot;yellow&quot;, &quot;black&quot;], {multiple: true, label: &quot;Inks&quot;})
```

[Source](./src/select.js) · [Examples](https://observablehq.com/@observablehq/input-select) · A Select allows the user to choose one of a given set of values (one of the given elements in the iterable *data*); or, if desired, multiple values may be chosen. Unlike a [Radio](#Radio), only one (or a few) choices are visible up-front, affording a compact display even when many options are available. If multiple choice is allowed via the *multiple* option, the Select’s value is an array of the elements from *data* that are currently selected; if single choice is required, the Select’s value is an element from *data*, or null if no choice has been made.

The elements in *data* need not be strings; they can be anything. To customize display, optional *keyof* and *valueof* functions may be given; the result of the *keyof* function for each element in *data* is displayed to the user, while the result of the *valueof* function is exposed as the Select’s value when selected. If *data* is a Map, the *keyof* function defaults to the map entry’s key (`([key]) =&gt; key`) and the *valueof* function defaults to the map entry’s value (`([, value]) =&gt; value`); otherwise, both *keyof* and *valueof* default to the identity function (`d =&gt; d`). For example, with [d3.group](https://github.com/d3/d3-array/blob/master/README.md#group):

```js
viewof sportAthletes = Inputs.select(d3.group(athletes, d =&gt; d.sport))
```

Keys may be sorted and uniqued via the *sort* and *unique* options, respectively. Elements in *data* are formatted via an optional *format* function which has the same defaults as *keyof*. While the *label* option may be either a string or an HTML element, the *format* function must return a string (unlike a Radio).

The available *options* are:

* *label* - a label; either a string or an HTML element.
* *multiple* - whether to allow multiple choice; defaults to false.
* *size* - if *multiple* is true, the number of options to show.
* *sort* - true, “ascending”, “descending”, or a comparator function to sort keys; defaults to false.
* *unique* - true to only show unique keys; defaults to false.
* *locale* - the current locale; defaults to English.
* *format* - a format function; defaults to [formatLocaleAuto](#formatLocaleAuto) composed with *keyof*.
* *keyof* - a function to return the key for the given element in *data*.
* *valueof* - a function to return the value of the given element in *data*.
* *value* - the initial value, an array if multiple choice is allowed.
* *width* - the width of the input (not including the label).
* *disabled* - whether input is disabled, or the disabled values; defaults to false.

### Table

#### Inputs.table(*data*, *options*)

[&lt;img src=&quot;./img/table.png&quot; alt=&quot;A Table input showing rows of Olympic athletes&quot; width=&quot;988&quot;&gt;](https://observablehq.com/@observablehq/input-table)

[Source](./src/table.js) · [Examples](https://observablehq.com/@observablehq/input-table) · A Table displays a tabular dataset; *data* should be an iterable of objects, such as the result of loading a CSV file. The *data* may also be a promise to the same, in which case the contents of the table will be lazily populated once the promise resolves. Each object corresponds to a row, while each field corresponds to a column. To improve performance with large datasets, the rows of the table are lazily rendered on scroll. Rows may be sorted by clicking column headers (once for ascending, then again for descending).

While intended primarily for display, a Table also serves as an input. The value of the Table is its selected rows: a filtered (and possibly sorted) view of the *data*. If the *data* is specified as a promise, while the promise is unresolved, the table’s value is undefined and attempting to set the value of the table will throw an error. Rows can be selected by clicking or shift-clicking checkboxes. See also [Search](#Search), which can be used for rapid filtering of the table’s rows.

By default, the Table infers the type of each column by inspecting values, assuming that non-null values in each column have consistent types. Numbers are formatted in the specified *locale*; dates are formatted in ISO 8601 UTC. Numbers columns are further right-aligned with [tabular figures](https://practicaltypography.com/alternate-figures.html) to assist comparison. The *format* and *align* of each column can be customized as options if desired.

By default, the Table uses fixed layout if *data* has fewer than twelve columns. This improves performance and avoids reflow when scrolling due to lazily-rendered rows. If *data* has twelve or more columns, the auto layout is used instead, which automatically sizes columns based on the content. This behavior can be changed by specifying the *layout* option explicitly.

The available *options* are:

* *columns* - the columns (property names) to show; defaults to *data*.columns.
* *value* - a subset of *data* to use as the initial selection (checked rows), or a *data* item if *multiple* is false.
* *rows* - the maximum number of rows to show; defaults to 11.5.
* *sort* - the column to sort by; defaults to null (input order).
* *reverse* - whether to reverse the initial sort (descending instead of ascending).
* *format* - an object of column name to format function.
* *align* - an object of column name to “left”, “right”, or “center”.
* *header* - an object of column name to corresponding header; either a string or HTML element.
* *width* - the table width, or an object of column name to width.
* *maxWidth* - the maximum table width, if any.
* *height* - the fixed table height, if any.
* *maxHeight* - the maximum table height, if any; defaults to (*rows* + 1) * 22 - 1.
* *layout* - the [table layout](https://developer.mozilla.org/en-US/docs/Web/CSS/table-layout); defaults to fixed for ≤12 columns.
* *required* - if true, the table’s value is all *data* if no selection; defaults to true.
* *multiple* - if true, allow multiple rows to be selected; defaults to true.

If *width* is “auto”, the table width will be based on the table contents; note that this may cause the table to resize as rows are lazily rendered.

### Text

#### Inputs.text(*options*)

[&lt;img src=&quot;./img/text.png&quot; alt=&quot;A Text input asking to enter your name&quot; width=&quot;640&quot;&gt;](https://observablehq.com/@observablehq/input-text)

```js
viewof name = Inputs.text({label: &quot;Name&quot;, placeholder: &quot;Enter your name&quot;})
```

[Source](./src/text.js) · [Examples](https://observablehq.com/@observablehq/input-text) · A Text allows freeform single-line text input. For example, a Text might be used to allow the user to enter a search query. (See also [Search](#Search).) By default, a Text will report its value immediately on input. If more deliberate behavior is desired, say if the input will trigger an expensive computation or remote API, the *submit* option can be set to true to wait until a button is clicked or the Enter key is pressed.

The available *options* are:

* *label* - a label; either a string or an HTML element.
* *type* - the [input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#input_types), such as “password” or “email”; defaults to “text”.
* *value* - the initial value; defaults to the empty string.
* *placeholder* - the [placeholder](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/placeholder) attribute.
* *spellcheck* - whether to activate the browser’s spell-checker.
* *autocomplete* - the [autocomplete](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete) attribute, as text or boolean (true for on, false for off).
* *autocapitalize* - the [autocapitalize](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/autocapitalize) attribute, as text or boolean (true for on, false for off).
* *pattern* - the [pattern](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/pattern) attribute.
* *minlength* - [minimum length](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/minlength) attribute.
* *maxlength* - [maximum length](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/maxlength) attribute.
* *min* - [minimum value](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/min) attribute; formatted appropriately, *e.g.* yyyy-mm-dd for the date type.
* *max* - [maximum value](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/max) attribute.
* *required* - if true, the input must be non-empty; defaults to *minlength* &gt; 0.
* *validate* - a function to check whether the text input is valid.
* *width* - the width of the input (not including the label).
* *submit* - whether to require explicit submission before updating; defaults to false.
* *datalist* - an iterable of suggested values.
* *readonly* - whether input is readonly; defaults to false.
* *disabled* - whether input is disabled; defaults to false.

If *validate* is not defined, [*text*.checkValidity](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#dom-cva-checkvalidity) is used. While the input is not considered valid, changes to the input will not be reported.

#### Inputs.email(*options*)

Like Inputs.text, but where *type* is email.

#### Inputs.tel(*options*)

Like Inputs.text, but where *type* is tel.

#### Inputs.url(*options*)

Like Inputs.text, but where *type* is url.

#### Inputs.password(*options*)

Like Inputs.text, but where *type* is password.

#### Inputs.color(*options*)

Like Inputs.text, but where *type* is color. The color value is represented as an RGB hexadecimal string such as #ff00ff. This type of input does not support the following options: *placeholder*, *pattern*, *spellcheck*, *autocomplete*, *autocapitalize*, *min*, *max*, *minlength*, *maxlength*.

### Textarea

#### Inputs.textarea(*options*)

[&lt;img src=&quot;./img/textarea.png&quot; alt=&quot;A Textarea asking for your biography&quot; width=&quot;660&quot;&gt;](https://observablehq.com/@observablehq/input-textarea)

```js
viewof bio = Inputs.textarea({label: &quot;Biography&quot;, placeholder: &quot;Tell us a little about yourself…&quot;})
```

[Source](./src/textarea.js) · [Examples](https://observablehq.com/@observablehq/input-textarea) · A Textarea allows multi-line freeform text input. By default, a Textarea will report its value immediately on input. If more deliberate behavior is desired, the *submit* option can be set to true to wait until a button is clicked or the appropriate keyboard shortcut (such as Command-Enter on macOS) is pressed.

The available *options* are:

* *label* - a label; either a string or an HTML element.
* *value* - the initial value; defaults to the empty string.
* *placeholder* - the [placeholder](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/placeholder) attribute.
* *spellcheck* - whether to activate the browser’s spell-checker.
* *autocomplete* - the [autocomplete](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete) attribute, as text or boolean (true for on, false for off).
* *autocapitalize* - the [autocapitalize](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/autocapitalize) attribute, as text or boolean (true for on, false for off).
* *minlength* - [minimum length](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/minlength) attribute.
* *maxlength* - [maximum length](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/maxlength) attribute.
* *required* - if true, the input must be non-empty; defaults to *minlength* &gt; 0.
* *validate* - a function to check whether the text input is valid.
* *width* - the width of the input (not including the label).
* *rows* - the number of rows of text to show.
* *resize* - if true, allow vertical resizing; defaults to *rows* &lt; 12.
* *submit* - whether to require explicit submission before updating; defaults to false.
* *readonly* - whether input is readonly; defaults to false.
* *disabled* - whether input is disabled; defaults to false.
* *monospace* - if true, use a monospace font.

If *validate* is not defined, [*text*.checkValidity](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#dom-cva-checkvalidity) is used. While the input is not considered valid, changes to the input will not be reported.

### Date

#### Inputs.date(*options*)

```js
viewof start = Inputs.date({label: &quot;Start date&quot;, value: &quot;1982-03-06&quot;})
```

[Source](./src/date.js) · [Examples](https://observablehq.com/@observablehq/input-date) · A Date allows a [calendar-based input](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/date). By default, a Date will report its value immediately on input. If more deliberate behavior is desired, say if the input will trigger an expensive computation or remote API, the *submit* option can be set to true to wait until a button is clicked or the Enter key is pressed.

The available *options* are:

* *label* - a label; either a string or an HTML element.
* *value* - the initial value, as a JavaScript Date or formatted as an ISO string (yyyy-mm-dd); defaults to null.
* *min* - [minimum value](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/min) attribute.
* *max* - [maximum value](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/max) attribute.
* *required* - if true, the input must be a valid date.
* *validate* - a function to check whether the text input is valid.
* *width* - the width of the input (not including the label).
* *submit* - whether to require explicit submission before updating; defaults to false.
* *readonly* - whether input is readonly; defaults to false.
* *disabled* - whether input is disabled; defaults to false.

The value of the input is a Date instance at UTC midnight of the specified date, or null if no (valid) value has been specified. Note that the displayed date format is [based on the browser’s locale](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/date).

#### Inputs.datetime(*options*)

```js
viewof start = Inputs.datetime({label: &quot;Start date&quot;, value: &quot;1982-03-06T02:30&quot;})
```

Like Inputs.date, but allows a time to also be specified in the user’s local time zone.

### File

#### Inputs.file(*options*)

```js
viewof recordsFile = Inputs.file({label: &quot;Records&quot;, accept: &quot;.json&quot;})
```
```js
records = recordsFile.json()
```

[Source](./src/file.js) · A file input allows the user to pick one or more local files. These files will be exposed as objects with the same API as [Observable file attachments](https://github.com/observablehq/stdlib/blob/main/README.md#file-attachments).

The available *options* are:

* *label* - a label; either a string or an HTML element.
* *required* - if true, a valid file must be selected.
* *validate* - a function to check whether the file input is valid.
* *accept* - the [acceptable file types](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#accept).
* *capture* - for [capturing image or video data](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#capture).
* *multiple* - whether to allow multiple files to be selected; defaults to false.
* *width* - the width of the input (not including the label).
* *disabled* - whether input is disabled; defaults to false.

Note that the value of file input cannot be set programmatically; it can only be changed by the user.

(In vanilla JavaScript, the Inputs.file method is not exposed directly. Instead, an Inputs.fileOf method is exposed which takes an AbstractFile implementation and returns the Inputs.file method. This avoids a circular dependency between Observable Inputs and the Observable standard library.)

## Utilities

#### Inputs.form(*inputs*, *options*)

[Source](./src/form.js) · [Examples](https://observablehq.com/@observablehq/input-form) · Returns a compound input for the specified array or object of *inputs*. This allows multiple inputs to be combined into a single cell for a more compact display. For example, to define an input for the value `rgb` that is a three-element array [*r*, *g*, *b*] of numbers:

```js
viewof rgb = Inputs.form([
  Inputs.range([0, 255], {step: 1, label: &quot;r&quot;}),
  Inputs.range([0, 255], {step: 1, label: &quot;g&quot;}),
  Inputs.range([0, 255], {step: 1, label: &quot;b&quot;})
])
```

Alternatively, to represent `rgb` as an object {*r*, *g*, *b*}:

```js
viewof rgb = Inputs.form({
  r: Inputs.range([0, 255], {step: 1, label: &quot;r&quot;}),
  g: Inputs.range([0, 255], {step: 1, label: &quot;g&quot;}),
  b: Inputs.range([0, 255], {step: 1, label: &quot;b&quot;})
})
```

The available *options* are:

* *template* - a function that takes the given *inputs* and returns an HTML element to display.

If the *template* object is not specified, the given inputs are wrapped in a DIV.

#### Inputs.input(*value*)

[Source](./src/input.js) · [Examples](https://observablehq.com/@observablehq/synchronized-inputs) · Returns an [EventTarget](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget) with the specified *value*. This is typically used in conjunction with [bind](#inputsbindtarget-source-invalidation) to synchronize multiple inputs, with the Input being the primary state store. An Input is similar to a [mutable](https://observablehq.com/@observablehq/introduction-to-mutable-state), except that it allows listeners.

#### Inputs.bind(*target*, *source*, *invalidation*)

[Source](./src/bind.js) · [Examples](https://observablehq.com/@observablehq/synchronized-inputs) · The bind function allows a *target* input to be bound to a *source* input, synchronizing the two: interaction with the *source* input will propagate to the *target* input and *vice versa*.

The relationship between *target* and *source* is not symmetric: the *target* input should be considered a dependant of the *source* input, and if desired, only the *source* should be declared an Observable view. For example:

```js
viewof i = Inputs.input(42) // the “primary” input
```
```js
Inputs.bind(Inputs.range([0, 100]), viewof i) // a bound “secondary” input
```

When the *target* emits a type-appropriate event, the *target*’s type-appropriate value will be applied to the *source* and a type-appropriate event will be dispatched on the *source*; when the *source* emits a type-appropriate event, the *source*’s type-appropriate value will be applied to the *target*, but *no event will be dispatched*, avoiding an infinite loop.

The type-appropriate event is a *click* event for buttons and submit inputs, a *change* event for file inputs, and an *input* event for anything else. The type-appropriate value is *input*.valueAsNumber for range and number inputs, *input*.valueAsDate for date inputs, *input*.checked for checkbox inputs, *input*.files for multiple file inputs, *input*.files[0] for single-file inputs, and *input*.value for anything else.

If *invalidation* is specified, it is a promise; when the promise resolves, the target will stop listening to the source. If *invalidation* is not specified, it defaults to the [disposal promise](#inputsdisposalelement) on the specified *target*. Note that source will remain listening to the target, however, until the target is garbage-collected.

#### Inputs.disposal(*element*)

[Source](./src/disposal.js) · The disposal promise is a heuristic for detecting when an input has been removed from the DOM, say to detach synchronized inputs. It is used by [bind](#inputsbindtarget-source-invalidation) by default as the invalidation promise, but is exported here for convenience.

#### Inputs.searchFilter(*query*)

[Source](./src/search.js) · The default query parser used by [Search](#Search).

#### Inputs.formatLocaleAuto(*locale*)

[Source](./src/format.js) · Returns a function that formats a given *value* as a string according to the specified *locale*. If *locale* is not specified, it defaults to English. If *value* is null, returns the empty string; if *value* is a number, calls [formatLocaleNumber](#formatLocaleNumber) if *value* is a date, calls [formatDate](#formatDate); otherwise coerces *value* to a string. The default formatter used by [Table](#Table).

#### Inputs.formatLocaleNumber(*locale*)

[Source](./src/format.js) · Returns a function that formats a given *number* as a string according to the specified *locale*. The default number formatter used by [Table](#Table).

#### Inputs.formatTrim(*number*)

[Source](./src/format.js) · The default number formatter used by [Range](#Range).

#### Inputs.formatDate(*date*)

[Source](./src/format.js) · The default date formatter used by [Table](#Table).
</pre>,<h3>rollup.config.js</h3>
        <pre>import crypto from &quot;crypto&quot;;
import fs from &quot;fs&quot;;
import path from &quot;path&quot;;
import {terser} from &quot;rollup-plugin-terser&quot;;
import node from &quot;@rollup/plugin-node-resolve&quot;;
import replace from &quot;@rollup/plugin-replace&quot;;
import json from &quot;@rollup/plugin-json&quot;;
import jsesc from &quot;jsesc&quot;;
import CleanCSS from &quot;clean-css&quot;;
import * as meta from &quot;./package.json&quot;;

const filename = meta.name.split(&quot;/&quot;).pop();

// Resolve HTL dependency.
const htl = JSON.parse(fs.readFileSync(&quot;./node_modules/htl/package.json&quot;, &quot;utf-8&quot;));
if (typeof htl.jsdelivr === &quot;undefined&quot;) throw new Error(&quot;unable to resolve htl&quot;);
const htlPath = `htl@${htl.version}/${htl.jsdelivr}`;

// Extract copyrights from the LICENSE.
const copyrights = fs.readFileSync(&quot;./LICENSE&quot;, &quot;utf-8&quot;)
  .split(/\n/g)
  .filter(line =&gt; /^copyright\s+/i.test(line))
  .map(line =&gt; line.replace(/^copyright\s+/i, &quot;&quot;));

// Create a content-hashed namespace for our styles.
const stylePath = path.resolve(&quot;./src/style.css&quot;);
const styleHash = crypto.createHash(&quot;sha256&quot;).update(fs.readFileSync(stylePath, &quot;utf8&quot;)).digest(&quot;hex&quot;).slice(0, 6);
const styleNs = `oi-${styleHash}`;

// A lil’ Rollup plugin to allow importing of style.css.
const css = {
  load(id) {
    if (id !== stylePath) return;
    return fs.readFileSync(id, &quot;utf8&quot;);
  },
  transform(input, id) {
    if (id !== stylePath) return;
    return {
      moduleSideEffects: true,
      code: `if (typeof document !== &apos;undefined&apos; &amp;&amp; !document.querySelector(&apos;.${styleNs}&apos;)) {
const style = document.createElement(&apos;style&apos;);
style.className = &apos;${styleNs}&apos;;
style.textContent = &apos;${jsesc(new CleanCSS().minify(input.replace(/\.__ns__\b/g, `.${styleNs}`)).styles)}&apos;;
document.head.appendChild(style);
}
`
    };
  }
};

const config = {
  input: &quot;bundle.js&quot;,
  external: [&quot;htl&quot;],
  output: {
    indent: false,
    banner: `// ${meta.name} v${meta.version} Copyright ${copyrights.join(&quot;, &quot;)}`,
    name: &quot;Inputs&quot;,
    format: &quot;umd&quot;,
    extend: true,
    globals: {&quot;htl&quot;: &quot;htl&quot;},
    paths: {&quot;htl&quot;: htlPath}
  },
  plugins: [
    css,
    json(),
    node(),
    replace({__ns__: styleNs, preventAssignment: true})
  ]
};

export default [
  {
    ...config,
    output: {
      ...config.output,
      file: `dist/${filename}.js`
    }
  },
  {
    ...config,
    output: {
      ...config.output,
      file: `dist/${filename}.min.js`
    },
    plugins: [
      ...config.plugins,
      terser({output: {preamble: config.output.banner}})
    ]
  }
];
</pre>,<h3>snowpack.config.js</h3>
        <pre>export default {
  alias: {
    &quot;@observablehq/inputs&quot;: &quot;./src/index.js&quot;
  },
  devOptions: {
    port: 8008
  },
  mount: {
    &quot;src&quot;: &quot;/src&quot;,
    &quot;test/data&quot;: &quot;/data&quot;,
    &quot;scratch&quot;: &quot;/&quot;
  }
};
</pre>,<div style="margin-left: 8rem;">
        <h2>img</h2>
        
      </div>,<div style="margin-left: 8rem;">
        <h2>src</h2>
        <h4>array.js</h4>
        <pre>export function arrayify(array) {
  return Array.isArray(array) ? array : Array.from(array);
}

function iterable(array) {
  return array ? typeof array[Symbol.iterator] === &quot;function&quot; : false;
}

export function maybeColumns(data) {
  if (iterable(data.columns)) return data.columns; // d3-dsv, FileAttachment
  if (data.schema &amp;&amp; iterable(data.schema.fields)) return Array.from(data.schema.fields, f =&gt; f.name); // apache-arrow
  if (typeof data.columnNames === &quot;function&quot;) return data.columnNames(); // arquero
}
</pre>,<h4>bind.js</h4>
        <pre>import {disposal} from &quot;./disposal.js&quot;;
import {bubbles} from &quot;./event.js&quot;;

export function bind(target, source, invalidation = disposal(target)) {
  const sourceEvent = eventof(source);
  const onsource = () =&gt; set(target, source);
  const ontarget = () =&gt; (set(source, target), source.dispatchEvent(new Event(sourceEvent, bubbles)));
  onsource();
  target.addEventListener(eventof(target), ontarget);
  source.addEventListener(sourceEvent, onsource);
  invalidation.then(() =&gt; source.removeEventListener(sourceEvent, onsource));
  return target;
}

function get(input) {
  switch (input.type) {
    case &quot;range&quot;:
    case &quot;number&quot;: return input.valueAsNumber;
    case &quot;date&quot;: return input.valueAsDate;
    case &quot;checkbox&quot;: return input.checked;
    case &quot;file&quot;: return input.multiple ? input.files : input.files[0];
    default: return input.value;
  }
}

function set(target, source) {
  const value = get(source);
  switch (target.type) {
    case &quot;range&quot;:
    case &quot;number&quot;: target.valueAsNumber = value; break;
    case &quot;date&quot;: target.valueAsDate = value; break;
    case &quot;checkbox&quot;: target.checked = value; break;
    case &quot;file&quot;: target.multiple ? (target.files = value) : (target.files = [value]); break;
    default: target.value = value; break;
  }
}

function eventof(input) {
  switch (input.type) {
    case &quot;button&quot;:
    case &quot;submit&quot;: return &quot;click&quot;;
    case &quot;file&quot;: return &quot;change&quot;;
    default: return &quot;input&quot;;
  }
}
</pre>,<h4>button.js</h4>
        <pre>import {html} from &quot;htl&quot;;
import {length} from &quot;./css.js&quot;;
import {dispatchInput, preventDefault} from &quot;./event.js&quot;;
import {identity} from &quot;./identity.js&quot;;
import {maybeLabel} from &quot;./label.js&quot;;

export function button(content = &quot;≡&quot;, {
  label = &quot;&quot;,
  value,
  reduce,
  disabled,
  required = false,
  width
} = {}) {
  const solitary = typeof content === &quot;string&quot; || content instanceof Node;
  if (solitary) {
    if (!required &amp;&amp; value === undefined) value = 0;
    if (reduce === undefined) reduce = (value = 0) =&gt; value + 1;
    disabled = new Set(disabled ? [content] : []);
    content = [[content, reduce]];
  } else {
    if (!required &amp;&amp; value === undefined) value = null;
    disabled = new Set(disabled === true ? Array.from(content, ([content]) =&gt; content) : disabled || undefined);
  }
  const form = html`&lt;form class=__ns__&gt;`;
  form.addEventListener(&quot;submit&quot;, preventDefault);
  const style = {width: length(width)};
  const buttons = Array.from(content, ([content, reduce = identity]) =&gt; {
    if (typeof reduce !== &quot;function&quot;) throw new TypeError(&quot;reduce is not a function&quot;);
    return html`&lt;button disabled=${disabled.has(content)} style=${style} onclick=${event =&gt; {
      form.value = reduce(form.value);
      dispatchInput(event);
    }}&gt;${content}`;
  });
  if (label = maybeLabel(label, solitary ? buttons[0] : undefined)) form.append(label);
  form.append(...buttons);
  form.value = value;
  return form;
}
</pre>,<h4>checkbox.js</h4>
        <pre>import {html} from &quot;htl&quot;;
import {createChooser} from &quot;./chooser.js&quot;;
import {stringify} from &quot;./format.js&quot;;
import {maybeLabel} from &quot;./label.js&quot;;

function createCheckbox(multiple, type) {
  return createChooser({
    multiple,
    render(data, index, selected, disabled, {format, label}) {
      const form = html`&lt;form class=&quot;__ns__ __ns__-checkbox&quot;&gt;
      ${maybeLabel(label)}&lt;div&gt;
        ${index.map(i =&gt; html`&lt;label&gt;&lt;input type=${type} disabled=${typeof disabled === &quot;function&quot; ? disabled(i) : disabled} name=input value=${i} checked=${selected(i)}&gt;${format(data[i], i, data)}`)}
      &lt;/div&gt;
    &lt;/form&gt;`;
      return [form, inputof(form.elements.input, multiple)];
    },
    selectedIndexes(input) {
      return Array.from(input).filter(i =&gt; i.checked).map(i =&gt; +i.value);
    },
    select(input, selected) {
      input.checked = selected;
    }
  });
}

export const radio = createCheckbox(false, &quot;radio&quot;);

export const checkbox = createCheckbox(true, &quot;checkbox&quot;);

export function toggle({label, value, values, disabled} = {}) {
  const input = html`&lt;input class=__ns__-input type=checkbox name=input disabled=${disabled}&gt;`;
  const form = html`&lt;form class=&quot;__ns__ __ns__-toggle&quot;&gt;${maybeLabel(label, input)}${input}`;
  Object.defineProperty(form, &quot;value&quot;, {
    get() {
      return values === undefined ? input.checked : values[input.checked ? 0 : 1];
    },
    set(v) {
      input.checked = values === undefined ? !!v : v === values[0];
    }
  });
  if (value !== undefined) form.value = value;
  return form;
}

// The input is undefined if there are no options, or an individual input
// element if there is only one; we want these two cases to behave the same as
// when there are two or more options, i.e., a RadioNodeList.
function inputof(input, multiple) {
  return input === undefined ? new OptionZero(multiple ? [] : null)
    : typeof input.length === &quot;undefined&quot; ? new (multiple ? MultipleOptionOne : OptionOne)(input)
    : input;
}

class OptionZero {
  constructor(value) {
    this._value = value;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    // ignore
  }
  *[Symbol.iterator]() {
    // empty
  }
}

// TODO If we allow selected radios to be cleared by command-clicking, then
// assigning a radio’s value programmatically should also clear the selection.
// This will require changing this class and also wrapping RadioNodeList in the
// common case to change the value setter’s behavior.
class OptionOne {
  constructor(input) {
    this._input = input;
  }
  get value() {
    const {_input} = this;
    return _input.checked ? _input.value : &quot;&quot;;
  }
  set value(v) {
    const {_input} = this;
    if (_input.checked) return;
    _input.checked = stringify(v) === _input.value;
  }
  *[Symbol.iterator]() {
    yield this._input;
  }
}

class MultipleOptionOne {
  constructor(input) {
    this._input = input;
    this._value = input.checked ? [input.value] : [];
  }
  get value() {
    return this._value;
  }
  set value(v) {
    const {_input} = this;
    if (_input.checked) return;
    _input.checked = stringify(v) === _input.value;
    this._value = _input.checked ? [_input.value] : [];
  }
  *[Symbol.iterator]() {
    yield this._input;
  }
}
</pre>,<h4>chooser.js</h4>
        <pre>import {arrayify} from &quot;./array.js&quot;;
import {dispatchInput, preventDefault} from &quot;./event.js&quot;;
import {formatLocaleAuto} from &quot;./format.js&quot;;
import {identity} from &quot;./identity.js&quot;;
import {ascending, descending} from &quot;./sort.js&quot;;

const first = ([x]) =&gt; x;
const second = ([, x]) =&gt; x;

export function createChooser({multiple: fixedMultiple, render, selectedIndexes, select}) {
  return function chooser(data, {
    locale,
    keyof = data instanceof Map ? first : identity,
    valueof = data instanceof Map ? second : identity,
    format = (f =&gt; (d, i, data) =&gt; f(keyof(d, i, data)))(formatLocaleAuto(locale)),
    multiple,
    key,
    value,
    disabled = false,
    sort,
    unique,
    ...options
  } = {}) {
    if (typeof keyof !== &quot;function&quot;) throw new TypeError(&quot;keyof is not a function&quot;);
    if (typeof valueof !== &quot;function&quot;) throw new TypeError(&quot;valueof is not a function&quot;);
    if (typeof format !== &quot;function&quot;) throw new TypeError(&quot;format is not a function&quot;);
    if (fixedMultiple !== undefined) multiple = fixedMultiple;
    sort = maybeSort(sort);
    let size = +multiple;
    if (value === undefined) value = key !== undefined &amp;&amp; data instanceof Map ? (size &gt; 0 ? Array.from(key, k =&gt; data.get(k)) : data.get(key)) : undefined;
    unique = !!unique;
    data = arrayify(data);
    let keys = data.map((d, i) =&gt; [keyof(d, i, data), i]);
    if (sort !== undefined) keys.sort(([a], [b]) =&gt; sort(a, b));
    if (unique) keys = [...new Map(keys.map(o =&gt; [intern(o[0]), o])).values()];
    const index = keys.map(second);
    if (multiple === true) size = Math.max(1, Math.min(10, index.length));
    else if (size &gt; 0) multiple = true;
    else multiple = false, size = undefined;
    const [form, input] = render(
      data,
      index,
      maybeSelection(data, index, value, multiple, valueof),
      maybeDisabled(data, index, disabled, valueof),
      {
        ...options,
        format,
        multiple,
        size
      }
    );
    form.addEventListener(&quot;input&quot;, oninput);
    form.addEventListener(&quot;change&quot;, dispatchInput);
    form.addEventListener(&quot;submit&quot;, preventDefault);
    function oninput(event) {
      if (event &amp;&amp; event.isTrusted) form.removeEventListener(&quot;change&quot;, dispatchInput);
      if (multiple) {
        value = selectedIndexes(input).map(i =&gt; valueof(data[i], i, data));
      } else {
        const i = selectedIndex(input);
        value = i &lt; 0 ? null : valueof(data[i], i, data);
      }
    }
    oninput();
    return Object.defineProperty(form, &quot;value&quot;, {
      get() {
        return value;
      },
      set(v) {
        if (multiple) {
          const selection = new Set(v);
          for (const e of input) {
            const i = +e.value;
            select(e, selection.has(valueof(data[i], i, data)));
          }
        } else {
          input.value = index.find(i =&gt; v === valueof(data[i], i, data));
        }
        oninput();
      }
    });
  };
}

function maybeSelection(data, index, value, multiple, valueof) {
  const values = new Set(value === undefined ? [] : multiple ? arrayify(value) : [value]);
  if (!values.size) return () =&gt; false;
  const selection = new Set();
  for (const i of index) {
    if (values.has(valueof(data[i], i, data))) {
      selection.add(i);
    }
  }
  return i =&gt; selection.has(i);
}

function maybeDisabled(data, index, value, valueof) {
  if (typeof value === &quot;boolean&quot;) return value;
  const values = new Set(arrayify(value));
  const disabled = new Set();
  for (const i of index) {
    if (values.has(valueof(data[i], i, data))) {
      disabled.add(i);
    }
  }
  return i =&gt; disabled.has(i);
}

function maybeSort(sort) {
  if (sort === undefined || sort === false) return;
  if (sort === true || sort === &quot;ascending&quot;) return ascending;
  if (sort === &quot;descending&quot;) return descending;
  if (typeof sort === &quot;function&quot;) return sort;
  throw new TypeError(&quot;sort is not a function&quot;);
}

function selectedIndex(input) {
  return input.value ? +input.value : -1;
}

function intern(value) {
  return value !== null &amp;&amp; typeof value === &quot;object&quot; ? value.valueOf() : value;
}
</pre>,<h4>color.js</h4>
        <pre>import {html} from &quot;htl&quot;;
import {maybeWidth} from &quot;./css.js&quot;;
import {maybeDatalist} from &quot;./datalist.js&quot;;
import {maybeLabel} from &quot;./label.js&quot;;
import {newId} from &quot;./id.js&quot;;
import {createText} from &quot;./text.js&quot;;

export function color({
  label,
  value,
  required,
  datalist,
  readonly,
  disabled,
  width,
  ...options
} = {}) {
  const [list, listId] = maybeDatalist(datalist);
  const id = newId();
  const input = html`&lt;input
    type=color
    name=text
    value=${value}
    id=${id}
    list=${listId}
    readonly=${readonly}
    disabled=${disabled}
    required=${required}
  &gt;`;
  const output = html`&lt;output
    for=${id}
  &gt;`;
  output.value = input.value;
  input.addEventListener(&quot;input&quot;, () =&gt; output.value = input.value);
  const form = html`&lt;form class=__ns__ style=${maybeWidth(width)}&gt;
    ${maybeLabel(label, input)}&lt;div class=__ns__-input&gt;
      &lt;div class=__ns__-input&gt;${input}${output}&lt;/div&gt;
    &lt;/div&gt;${list}
  &lt;/form&gt;`;
  return createText(form, input, value, options, {
    after: (button) =&gt; input.parentNode.after(button)
  });
}
</pre>,<h4>css.js</h4>
        <pre>export function length(x) {
  return x == null ? null : typeof x === &quot;number&quot; ? `${x}px` : `${x}`;
}

export function maybeWidth(width) {
  return {&quot;--input-width&quot;: length(width)};
}
</pre>,<h4>datalist.js</h4>
        <pre>import {html} from &quot;htl&quot;;
import {stringify} from &quot;./format.js&quot;;
import {newId} from &quot;./id.js&quot;;

export function maybeDatalist(datalist) {
  if (datalist === undefined) return [null, null];
  const listId = newId();
  const list = html`&lt;datalist id=${listId}&gt;${Array.from(datalist, value =&gt; html`&lt;option value=${stringify(value)}&gt;`)}`;
  return [list, listId];
}
</pre>,<h4>date.js</h4>
        <pre>import {html} from &quot;htl&quot;;
import {parse as isoparse} from &quot;isoformat&quot;;
import {maybeWidth} from &quot;./css.js&quot;;
import {maybeLabel} from &quot;./label.js&quot;;
import {createText} from &quot;./text.js&quot;;

const dateops = {
  type: &quot;date&quot;,
  get: (input) =&gt; input.valueAsDate,
  set: (input, value) =&gt; input.value = formatDate(value),
  same: (input, value) =&gt; +input.valueAsDate === +value,
  format: formatDate
};

// datetime-local pedantically refuses to support valueAsDate, so here we use
// the Date constructor to convert the input based on the user’s local time zone
// (which you think would be implied by datetime-local)?
// https://github.com/whatwg/html/issues/4770
const datetimeops = {
  type: &quot;datetime-local&quot;,
  get: (input) =&gt; input.value ? new Date(input.value) : null,
  set: (input, value) =&gt; input.value = formatDatetime(value),
  same: (input, value) =&gt; +new Date(input.value) === +value,
  format: formatDatetime
};

function createDate({
  label,
  min,
  max,
  required,
  readonly,
  disabled,
  width,
  value,
  ...options
} = {}, {
  type,
  format,
  ...ops
}) {
  const input = html`&lt;input type=${type} name=date readonly=${readonly} disabled=${disabled} required=${required} min=${format(min)} max=${format(max)}&gt;`;
  const form = html`&lt;form class=__ns__ style=${maybeWidth(width)}&gt;
    ${maybeLabel(label, input)}&lt;div class=__ns__-input&gt;
      ${input}
    &lt;/div&gt;
  &lt;/form&gt;`;
  return createText(form, input, coerce(value), options, ops);
}

export function date(options) {
  return createDate(options, dateops);
}

export function datetime(options) {
  return createDate(options, datetimeops);
}

function coerce(value) {
  return value instanceof Date &amp;&amp; !isNaN(value) ? value
    : typeof value === &quot;string&quot; ? isoparse(value, null)
    : value == null || isNaN(value = +value) ? null
    : new Date(+value);
}

function formatDate(value) {
  return (value = coerce(value))
    ? value.toISOString().slice(0, 10)
    : value;
}

// The datetime-local input uses YYYY-MM-DDThh:mm like ISO 8601, but in local
// time rather than UTC, so we apply the offset before calling toISOString.
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/datetime-local
function formatDatetime(value) {
  return (value = coerce(value))
    ? (new Date(+value - value.getTimezoneOffset() * 1000 * 60)).toISOString().slice(0, 16)
    : value;
}
</pre>,<h4>disposal.js</h4>
        <pre>export function disposal(element) {
  return new Promise(resolve =&gt; {
    requestAnimationFrame(() =&gt; {
      const target = element.closest(&quot;.observablehq&quot;);
      if (!target) return resolve();
      const observer = new MutationObserver(() =&gt; {
        if (target.contains(element)) return;
        observer.disconnect(), resolve();
      });
      observer.observe(target, {childList: true});
    });
  });
}
</pre>,<h4>event.js</h4>
        <pre>export const bubbles = {bubbles: true};

export function preventDefault(event) {
  event.preventDefault();
}

export function dispatchInput({currentTarget}) {
  (currentTarget.form || currentTarget).dispatchEvent(new Event(&quot;input&quot;, bubbles));
}

export function checkValidity(input) {
  return input.checkValidity();
}
</pre>,<h4>file.js</h4>
        <pre>import {html} from &quot;htl&quot;;
import {maybeWidth} from &quot;./css.js&quot;;
import {maybeLabel} from &quot;./label.js&quot;;
import {createText} from &quot;./text.js&quot;;

export function fileOf(AbstractFile) {

  class LocalFile extends AbstractFile {
    constructor(file) {
      super(file.name);
      Object.defineProperty(this, &quot;_&quot;, {value: file});
      Object.defineProperty(this, &quot;_url&quot;, {writable: true});
    }
    async url() {
      return this._url || (this._url = URL.createObjectURL(this._));
    }
    async blob() {
      return this._;
    }
    async stream() {
      return this._.stream();
    }
  }

  return function file({
    label,
    required,
    accept,
    capture,
    multiple,
    disabled,
    width,
    value, // eslint-disable-line no-unused-vars
    submit, // eslint-disable-line no-unused-vars
    ...options
  } = {}) {
    const input = html`&lt;input
      type=file
      name=file
      disabled=${disabled}
      required=${required}
      accept=${accept}
      capture=${capture}
      multiple=${multiple}
    &gt;`;
    const form = html`&lt;form class=__ns__ style=${maybeWidth(width)}&gt;
      ${maybeLabel(label, input)}&lt;div class=__ns__-input&gt;
        ${input}
      &lt;/div&gt;
    &lt;/form&gt;`;
    return createText(form, input, undefined, options, {
      get: (input) =&gt; multiple ? Array.from(input.files, file =&gt; new LocalFile(file))
        : input.files.length ? new LocalFile(input.files[0])
        : null,
      set: () =&gt; {}, // ignored
      same: () =&gt; false // ignored
    });
  };
}
</pre>,<h4>form.js</h4>
        <pre>import {html} from &quot;htl&quot;;

export function form(inputs, options) {
  return (Array.isArray(inputs) ? arrayForm : objectForm)(inputs, options);
}

function arrayTemplate(inputs) {
  return html`&lt;div&gt;${inputs}`;
}

function arrayForm(inputs, {template = arrayTemplate} = {}) {
  inputs = [...inputs]; // defensive copy
  let value = inputs.map(({value}) =&gt; value);
  return Object.defineProperty(template(inputs), &quot;value&quot;, {
    get() {
      for (let i = 0, n = inputs.length; i &lt; n; ++i) {
        const v = inputs[i].value;
        if (!Object.is(v, value[i])) {
          value = [...value];
          value[i] = v;
        }
      }
      return value;
    },
    set(v = []) {
      for (let i = 0, n = inputs.length; i &lt; n; ++i) {
        inputs[i].value = v[i];
      }
    }
  });
}

function objectTemplate(inputs) {
  return html`&lt;div&gt;${Object.values(inputs)}`;
}

function objectForm(inputs, {template = objectTemplate} = {}) {
  inputs = {...inputs}; // defensive copy
  let value = Object.fromEntries(Object.entries(inputs).map(([name, {value}]) =&gt; [name, value]));
  return Object.defineProperty(template(inputs), &quot;value&quot;, {
    get() {
      for (const k in value) {
        const v = inputs[k].value;
        if (!Object.is(v, value[k])) {
          value = {...value};
          value[k] = v;
        }
      }
      return value;
    },
    set(v = {}) {
      for (const name in inputs) {
        inputs[name].value = v[name];
      }
    }
  });
}
</pre>,<h4>format.js</h4>
        <pre>import {format as isoformat} from &quot;isoformat&quot;;

// Note: use formatAuto (or any other localized format) to present values to the
// user; stringify is only intended for machine values.
export function stringify(x) {
  return x == null ? &quot;&quot; : `${x}`;
}

export const formatLocaleAuto = localize(locale =&gt; {
  const formatNumber = formatLocaleNumber(locale);
  return value =&gt; value == null ? &quot;&quot;
    : typeof value === &quot;number&quot; ? formatNumber(value)
    : value instanceof Date ? formatDate(value)
    : `${value}`;
});

export const formatLocaleNumber = localize(locale =&gt; {
  return value =&gt; value === 0 ? &quot;0&quot; : value.toLocaleString(locale); // handle negative zero
});

export const formatAuto = formatLocaleAuto();

export const formatNumber = formatLocaleNumber();

export function formatTrim(value) {
  const s = value.toString();
  const n = s.length;
  let i0 = -1, i1;
  out: for (let i = 1; i &lt; n; ++i) {
    switch (s[i]) {
      case &quot;.&quot;: i0 = i1 = i; break;
      case &quot;0&quot;: if (i0 === 0) i0 = i; i1 = i; break;
      default: if (!+s[i]) break out; if (i0 &gt; 0) i0 = 0; break;
    }
  }
  return i0 &gt; 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

export function formatDate(date) {
  return isoformat(date, &quot;Invalid Date&quot;);
}

// Memoize the last-returned locale.
export function localize(f) {
  let key = localize, value;
  return (locale = &quot;en&quot;) =&gt; locale === key ? value : (value = f(key = locale));
}
</pre>,<h4>id.js</h4>
        <pre>let nextId = 0;

export function newId() {
  return `__ns__-${++nextId}`;
}
</pre>,<h4>identity.js</h4>
        <pre>export function identity(x) {
  return x;
}
</pre>,<h4>index.js</h4>
        <pre>export {button} from &quot;./button.js&quot;;
export {checkbox, radio, toggle} from &quot;./checkbox.js&quot;;
export {color} from &quot;./color.js&quot;;
export {date, datetime} from &quot;./date.js&quot;;
export {form} from &quot;./form.js&quot;;
export {fileOf} from &quot;./file.js&quot;;
export {range, number} from &quot;./range.js&quot;;
export {search, searchFilter} from &quot;./search.js&quot;;
export {select} from &quot;./select.js&quot;;
export {table} from &quot;./table.js&quot;;
export {text, email, tel, url, password} from &quot;./text.js&quot;;
export {textarea} from &quot;./textarea.js&quot;;
export {input} from &quot;./input.js&quot;;
export {bind} from &quot;./bind.js&quot;;
export {disposal} from &quot;./disposal.js&quot;;
export {formatDate, formatLocaleAuto, formatLocaleNumber, formatTrim} from &quot;./format.js&quot;;
export {formatAuto, formatNumber} from &quot;./format.js&quot;; // deprecated! use localized variants
</pre>,<h4>input.js</h4>
        <pre>export function input(value) {
  const target = new EventTarget();
  target.value = value;
  return target;
}
</pre>,<h4>intern.js</h4>
        <pre>export function intern(value) {
  return value !== null &amp;&amp; typeof value === &quot;object&quot; ? value.valueOf() : value;
}
</pre>,<h4>label.js</h4>
        <pre>import {html} from &quot;htl&quot;;
import {newId} from &quot;./id.js&quot;;

export function maybeLabel(label, input) {
  if (!label) return;
  label = html`&lt;label&gt;${label}`;
  if (input !== undefined) label.htmlFor = input.id = newId();
  return label;
}
</pre>,<h4>range.js</h4>
        <pre>import {html} from &quot;htl&quot;;
import {maybeWidth} from &quot;./css.js&quot;;
import {checkValidity, preventDefault} from &quot;./event.js&quot;;
import {formatTrim} from &quot;./format.js&quot;;
import {identity} from &quot;./identity.js&quot;;
import {maybeLabel} from &quot;./label.js&quot;;

const epsilon = 1e-6;

export function number(extent, options) {
  if (arguments.length &lt; 2) options = extent, extent = undefined;
  if (extent === undefined) extent = [];
  return createRange({extent}, options);
}

export function range(extent = [0, 1], options) {
  return createRange({extent, range: true}, options);
}

function createRange({
  extent: [min, max],
  range
}, {
  format = formatTrim,
  transform,
  invert,
  label = &quot;&quot;,
  value: initialValue,
  step,
  disabled,
  placeholder,
  validate = checkValidity,
  width
} = {}) {
  let value;
  if (typeof format !== &quot;function&quot;) throw new TypeError(&quot;format is not a function&quot;);
  if (min == null || isNaN(min = +min)) min = -Infinity;
  if (max == null || isNaN(max = +max)) max = Infinity;
  if (min &gt; max) [min, max] = [max, min], transform === undefined &amp;&amp; (transform = negate);
  if (step !== undefined) step = +step;
  const number = html`&lt;input type=number min=${isFinite(min) ? min : null} max=${isFinite(max) ? max : null} step=${step == undefined ? &quot;any&quot; : step} name=number required placeholder=${placeholder} oninput=${onnumber} disabled=${disabled}&gt;`;
  let irange; // untransformed range for coercion
  if (range) {
    if (transform === undefined) transform = identity;
    if (typeof transform !== &quot;function&quot;) throw new TypeError(&quot;transform is not a function&quot;);
    if (invert === undefined) invert = transform.invert === undefined ? solver(transform) : transform.invert;
    if (typeof invert !== &quot;function&quot;) throw new TypeError(&quot;invert is not a function&quot;);
    let tmin = +transform(min), tmax = +transform(max);
    if (tmin &gt; tmax) [tmin, tmax] = [tmax, tmin];
    range = html`&lt;input type=range min=${isFinite(tmin) ? tmin : null} max=${isFinite(tmax) ? tmax : null} step=${step === undefined || (transform !== identity &amp;&amp; transform !== negate) ? &quot;any&quot; : step} name=range oninput=${onrange} disabled=${disabled}&gt;`;
    irange = transform === identity ? range : html`&lt;input type=range min=${min} max=${max} step=${step === undefined ? &quot;any&quot; : step} name=range disabled=${disabled}&gt;`;
  } else {
    range = null;
    transform = invert = identity;
  }
  const form = html`&lt;form class=__ns__ style=${maybeWidth(width)}&gt;
    ${maybeLabel(label, number)}&lt;div class=__ns__-input&gt;
      ${number}${range}
    &lt;/div&gt;
  &lt;/form&gt;`;
  form.addEventListener(&quot;submit&quot;, preventDefault);
  // If range, use an untransformed range to round to the nearest valid value.
  function coerce(v) {
    if (!irange) return +v;
    v = Math.max(min, Math.min(max, v));
    if (!isFinite(v)) return v;
    irange.valueAsNumber = v;
    return irange.valueAsNumber;
  }
  function onrange(event) {
    const v = coerce(invert(range.valueAsNumber));
    if (isFinite(v)) {
      number.valueAsNumber = Math.max(min, Math.min(max, v));
      if (validate(number)) {
        value = number.valueAsNumber;
        number.value = format(value);
        return;
      }
    }
    if (event) event.stopPropagation();
  }
  function onnumber(event) {
    const v = coerce(number.valueAsNumber);
    if (isFinite(v)) {
      if (range) range.valueAsNumber = transform(v);
      if (validate(number)) {
        value = v;
        return;
      }
    }
    if (event) event.stopPropagation();
  }
  Object.defineProperty(form, &quot;value&quot;, {
    get() {
      return value;
    },
    set(v) {
      v = coerce(v);
      if (isFinite(v)) {
        number.valueAsNumber = v;
        if (range) range.valueAsNumber = transform(v);
        if (validate(number)) {
          value = v;
          number.value = format(value);
        }
      }
    }
  });
  if (initialValue === undefined &amp;&amp; irange) initialValue = irange.valueAsNumber; // (min + max) / 2
  if (initialValue !== undefined) form.value = initialValue; // invoke setter
  return form;
}

function negate(x) {
  return -x;
}

function square(x) {
  return x * x;
}

function solver(f) {
  if (f === identity || f === negate) return f;
  if (f === Math.sqrt) return square;
  if (f === Math.log) return Math.exp;
  if (f === Math.exp) return Math.log;
  return x =&gt; solve(f, x, x);
}

function solve(f, y, x) {
  let steps = 100, delta, f0, f1;
  x = x === undefined ? 0 : +x;
  y = +y;
  do {
    f0 = f(x);
    f1 = f(x + epsilon);
    if (f0 === f1) f1 = f0 + epsilon;
    x -= delta = (-1 * epsilon * (f0 - y)) / (f0 - f1);
  } while (steps-- &gt; 0 &amp;&amp; Math.abs(delta) &gt; epsilon);
  return steps &lt; 0 ? NaN : x;
}
</pre>,<h4>search.js</h4>
        <pre>import {html} from &quot;htl&quot;;
import {arrayify, maybeColumns} from &quot;./array.js&quot;;
import {maybeWidth} from &quot;./css.js&quot;;
import {maybeDatalist} from &quot;./datalist.js&quot;;
import {preventDefault} from &quot;./event.js&quot;;
import {formatLocaleNumber, localize, stringify} from &quot;./format.js&quot;;
import {maybeLabel} from &quot;./label.js&quot;;
import {onoff, truefalse} from &quot;./text.js&quot;;

export function search(data, {
  locale,
  format = formatResults(locale), // length format
  label,
  query = &quot;&quot;, // initial search query
  placeholder = &quot;Search&quot;, // placeholder text to show when empty
  columns = maybeColumns(data),
  spellcheck,
  autocomplete,
  autocapitalize,
  filter = columns === undefined ? searchFilter : columnFilter(columns), // returns the filter function given query
  datalist,
  disabled,
  required = true, // if true, the value is everything if nothing is selected
  width
} = {}) {
  let value = [];
  data = arrayify(data);
  required = !!required;
  const [list, listId] = maybeDatalist(datalist);
  const input = html`&lt;input
    name=input
    type=search
    list=${listId}
    disabled=${disabled}
    spellcheck=${truefalse(spellcheck)}
    autocomplete=${onoff(autocomplete)}
    autocapitalize=${onoff(autocapitalize)}
    placeholder=${placeholder}
    value=${query}
    oninput=${oninput}
  &gt;`;
  const output = html`&lt;output name=output&gt;`;
  const form = html`&lt;form class=__ns__ style=${maybeWidth(width)}&gt;
    ${maybeLabel(label, input)}&lt;div class=__ns__-input&gt;
      ${input}${output}
    &lt;/div&gt;${list}
  &lt;/form&gt;`;
  form.addEventListener(&quot;submit&quot;, preventDefault);
  function oninput() {
    value = input.value || required ? data.filter(filter(input.value)) : [];
    if (columns !== undefined) value.columns = columns;
    output.value = format(value.length);
  }
  oninput();
  return Object.defineProperties(form, {
    value: {
      get() {
        return value;
      }
    },
    query: {
      get() {
        return query;
      },
      set(v) {
        query = input.value = stringify(v);
        oninput();
      }
    }
  });
}

export function searchFilter(query) {
  const filters = `${query}`.split(/\s+/g).filter(t =&gt; t).map(termFilter);
  return d =&gt; {
    if (d == null) return false;
    if (typeof d === &quot;object&quot;) {
      out: for (const filter of filters) {
        for (const value of valuesof(d)) {
          if (filter.test(value)) {
            continue out;
          }
        }
        return false;
      }
    } else {
      for (const filter of filters) {
        if (!filter.test(d)) {
          return false;
        }
      }
    }
    return true;
  };
}

function columnFilter(columns) {
  return query =&gt; {
    const filters = `${query}`.split(/\s+/g).filter(t =&gt; t).map(termFilter);
    return d =&gt; {
      out: for (const filter of filters) {
        for (const column of columns) {
          if (filter.test(d[column])) {
            continue out;
          }
        }
        return false;
      }
      return true;
    };
  };
}

function* valuesof(d) {
  for (const key in d) {
    yield d[key];
  }
}

function termFilter(term) {
  return new RegExp(`(?:^|[^\\p{L}-])${escapeRegExp(term)}`, &quot;iu&quot;);
}

function escapeRegExp(text) {
  return text.replace(/[\\^$.*+?()[\]{}|]/g, &quot;\\$&amp;&quot;);
}

const formatResults = localize(locale =&gt; {
  const formatNumber = formatLocaleNumber(locale);
  return length =&gt; `${formatNumber(length)} result${length === 1 ? &quot;&quot; : &quot;s&quot;}`;
});
</pre>,<h4>select.js</h4>
        <pre>import {html} from &quot;htl&quot;;
import {createChooser} from &quot;./chooser.js&quot;;
import {maybeWidth} from &quot;./css.js&quot;;
import {stringify} from &quot;./format.js&quot;;
import {maybeLabel} from &quot;./label.js&quot;;

export const select = createChooser({
  render(data, index, selected, disabled, {format, multiple, size, label, width}) {
    const select = html`&lt;select class=__ns__-input disabled=${disabled === true} multiple=${multiple} size=${size} name=input&gt;
      ${index.map(i =&gt; html`&lt;option value=${i} disabled=${typeof disabled === &quot;function&quot; ? disabled(i) : false} selected=${selected(i)}&gt;${stringify(format(data[i], i, data))}`)}
    &lt;/select&gt;`;
    const form = html`&lt;form class=__ns__ style=${maybeWidth(width)}&gt;${maybeLabel(label, select)}${select}`;
    return [form, select];
  },
  selectedIndexes(input) {
    return Array.from(input.selectedOptions, i =&gt; +i.value);
  },
  select(input, selected) {
    input.selected = selected;
  }
});
</pre>,<h4>sort.js</h4>
        <pre>export function ascending(a, b) {
  return defined(b) - defined(a) || (a &lt; b ? -1 : a &gt; b ? 1 : a &gt;= b ? 0 : NaN);
}

export function descending(b, a) {
  return defined(a) - defined(b) || (a &lt; b ? -1 : a &gt; b ? 1 : a &gt;= b ? 0 : NaN);
}

export function defined(d) {
  return d != null &amp;&amp; !Number.isNaN(d);
}
</pre>,<h4>style.css</h4>
        <pre>/* The root namespace; either a form (for inputs) or a div (for Table). */
.__ns__ {
  --length1: 3.25px;
  --length2: 6.5px;
  --length3: 13px;
  --label-width: 120px;
  --input-width: 240px;
  font: 13px/1.2 var(--sans-serif);
}

/* The minimum height of a form should match the minimum allowed cell height.
 * The vertical margins ensure adequate separation in narrow windows when used
 * with Inputs.form. */
form.__ns__ {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  min-height: 25.5px;
  margin: var(--length3) 0;
}

/* On narrow screens, the label is drawn as a block element on top of the
 * inputs, and a small amount of vertical padding is desired for separation. */
form.__ns__ &gt; label {
  width: 100%;
  padding-bottom: 3px;
}

/* On narrow screens, a toggle is small enough to fit inline with the label;
 * we don’t need to force it onto its own line as we do with other inputs. */
form.__ns__-toggle {
  flex-wrap: nowrap;
}

/* Since toggles won’t wrap on narrow screens, always align them vertically. */
form.__ns__-toggle &gt; label {
  align-self: start;
  padding: 5px 0 4px 0;
  margin-right: var(--length2);
}

/* Since toggles won’t wrap on narrow screens, collpase to content. */
form.__ns__-toggle &gt; label,
form.__ns__-toggle .__ns__-input {
  width: initial;
}

@media only screen and (min-width: 30em) {
  /* On wide screens, the label and inputs are side-by-side, with the label
   * having a fixed width for consistent layout across cells. */
  form.__ns__ {
    flex-wrap: nowrap;
    width: calc(var(--input-width) + var(--label-width));
    max-width: 100%;
    margin: initial;
  }
  /* On wide screens, we need to handle: the label being taller than the inputs;
   * the inputs being taller than the label; or both being a single line. In the
   * last (common) case, we want the single line to be vertically-centered
   * within the minimum cell height of 25.5px. In the other cases, we want the
   * two to be vertically-aligned at the top. In all cases we also want a small
   * amount of horizontal separation. */
  form.__ns__ &gt; label {
    flex-shrink: 0;
    align-self: start;
    padding: 5px 0 4px 0;
    width: var(--label-width);
    margin-right: var(--length2);
  }
}

/* A kind of “reset.css” to make these elements well-behaved. */
.__ns__ button,
.__ns__ input,
.__ns__ select,
.__ns__ table,
.__ns__ textarea {
  color: inherit;
  font: inherit;
  box-sizing: border-box;
}

.__ns__ button,
.__ns__ input {
  line-height: normal;
}

.__ns__ button {
  margin: 0;
}

/* Separate adjacent buttons. */
.__ns__ button + button {
  margin-left: var(--length1);
}

.__ns__-textarea {
  --input-width: 520px;
}

.__ns__-textarea &gt; div {
  width: 100%;
  text-align: right;
}

.__ns__-textarea &gt; div textarea {
  display: block;
  width: 100%;
  margin: 0;
  padding: 4px;
  min-height: calc(2.5em + 8px);
  max-height: calc(14em + 8px);
  resize: vertical;
}

.__ns__-textarea &gt; div button {
  margin: 4px 0 0;
}

/* Consistent horizontal spacing for labeled radios and checkboxes. */
.__ns__ input[type=radio],
.__ns__ input[type=checkbox] {
  margin-right: var(--length2);
}

/* For compound inputs (e.g., text input + submit), use flex to ensure vertical
 * alignment and to allow responsive sizing. For all inputs except Checkbox,
 * Radio, and Button, we want the inputs to span the full width of the form. */
.__ns__-input {
  display: flex;
  align-items: center;
  width: 100%;
}

/* Have these elements observe flex layout, per above. */
.__ns__-input &gt; input,
.__ns__-input &gt; button,
.__ns__-input &gt; output {
  width: inherit;
  min-width: 0;
}

/* Tell the secondary element to shrink more; e.g., the submit button should be
 * smaller than the text input, but both should grow proportionally. */
.__ns__-input &gt; button,
.__ns__-input &gt; output,
.__ns__-input &gt; input[type=number] {
  flex-shrink: 2.5;
}

/* Don’t allow text to wrap in search result counts (unless intended), and
 * separate the output from the preceding input. */
.__ns__-input &gt; output {
  white-space: pre;
  margin-left: var(--length2);
}

/* Separate the submit button from the preceding text input. */
.__ns__-input &gt; button {
  margin-left: var(--length1);
}

/* Use tabular-nums to avoid jitter when moving the range slider. */
.__ns__-input &gt; input[type=number] {
  font-variant-numeric: tabular-nums;
  flex-shrink: 1.5;
  text-overflow: ellipsis;
}

/* If possible, show the color input output in the system’s monospace font. */
.__ns__-input &gt; input[type=color] ~ output {
  font-family: ui-monospace, var(--monospace);
}

/* When a color input has a submit button, reserve more space for the output. */
.__ns__-input:not(:only-child) &gt; input[type=color] ~ output {
  flex-shrink: 1;
}

/* Separate the range input from the preceding number input. */
.__ns__-input &gt; input[type=range] {
  margin: 0;
  margin-left: var(--length2);
}

/* Tweak the height so that date inputs match text (and others). */
.__ns__-input &gt; input[type=date],
.__ns__-input &gt; input[type=datetime-local] {
  height: 22px;
}

/* Checkboxes and radios aren’t constrained by their input width; */
form.__ns__-checkbox {
  width: auto;
  max-width: 640px;
}

/* Vertically-align the label contents, and give ample horizontal separation. */
.__ns__-checkbox div label {
  display: inline-flex;
  align-items: center;
  margin-right: var(--length3);
}

form.__ns__-table {
  display: block;
  overflow-y: auto;
  width: 100%;
}

.__ns__-table table {
  max-width: initial;
  min-height: 33px;
  margin: 0;
  border-collapse: separate;
  border-spacing: 0;
  font-variant-numeric: tabular-nums;
}

.__ns__-table tr:not(:last-child) td,
.__ns__-table tr:not(:last-child) th {
  border-bottom: solid 1px #eee;
}

.__ns__-table thead tr td,
.__ns__-table thead tr th {
  border-bottom: solid 1px #ccc;
}

.__ns__-table thead th span {
  display: inline-block;
  width: 0.5em;
  margin-left: -0.5em;
}

.__ns__-table td,
.__ns__-table th {
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
  padding: 3px 6.5px 3px 0;
}

.__ns__-table tr &gt; :not(:first-of-type) {
  padding-left: var(--length2);
}

.__ns__-table tr &gt; :last-of-type {
  padding-right: var(--length3);
}

.__ns__-table tr &gt; :first-of-type {
  text-overflow: unset;
  width: 19px;
}

.__ns__-table tr &gt; :first-of-type input {
  opacity: 0;
  margin: 0 3px 1px 4px;
}

.__ns__-table tr:hover &gt; :first-of-type input:enabled,
.__ns__-table tr &gt; :first-of-type input:focus,
.__ns__-table tr &gt; :first-of-type input:checked,
.__ns__-table tr &gt; :first-of-type input[type=checkbox]:indeterminate {
  opacity: inherit;
}

.__ns__-table thead tr {
  border-bottom: none;
}

.__ns__-table thead th {
  position: sticky;
  top: 0;
  background: white;
  cursor: ns-resize;
}

.__ns__-table tbody tr:first-child td {
  padding-top: 4px;
}
</pre>,<h4>table.js</h4>
        <pre>import {html} from &quot;htl&quot;;
import {arrayify, maybeColumns} from &quot;./array.js&quot;;
import {length} from &quot;./css.js&quot;;
import {formatDate, formatLocaleAuto, formatLocaleNumber} from &quot;./format.js&quot;;
import {newId} from &quot;./id.js&quot;;
import {identity} from &quot;./identity.js&quot;;
import {defined, ascending, descending} from &quot;./sort.js&quot;;

const rowHeight = 22;

export function table(data, options = {}) {
  const {
    rows = 11.5, // maximum number of rows to show
    height,
    maxHeight = height === undefined ? (rows + 1) * rowHeight - 1 : undefined,
    width = {}, // object of column name to width, or overall table width
    maxWidth
  } = options;
  const id = newId();
  const root = html`&lt;form class=&quot;__ns__ __ns__-table&quot; id=${id} style=${{height: length(height), maxHeight: length(maxHeight), width: typeof width === &quot;string&quot; || typeof width === &quot;number&quot; ? length(width) : undefined, maxWidth: length(maxWidth)}}&gt;`;
  // The outer form element is created synchronously, while the table is lazily
  // created when the data promise resolves. This allows you to pass a promise
  // of data to the table without an explicit await.
  if (data &amp;&amp; typeof data.then === &quot;function&quot;) {
    Object.defineProperty(root, &quot;value&quot;, {
      configurable: true, // allow defineProperty again on initialization
      set() {
        throw new Error(&quot;cannot set value while data is unresolved&quot;);
      }
    });
    Promise.resolve(data).then(data =&gt; initialize({root, id}, data, options));
  } else {
    initialize({root, id}, data, options);
  }
  return root;
}

function initialize(
  {
    root,
    id
  },
  data,
  {
    columns = maybeColumns(data), // array of column names
    value, // initial selection
    required = true, // if true, the value is everything if nothing is selected
    sort, // name of column to sort by, if any
    reverse = false, // if sorting, true for descending and false for ascending
    format, // object of column name to format function
    locale,
    align, // object of column name to left, right, or center
    header, // object of column name to string or HTML element
    rows = 11.5, // maximum number of rows to show
    width = {}, // object of column name to width, or overall table width
    multiple = true,
    layout // &quot;fixed&quot; or &quot;auto&quot;
  } = {}
) {
  columns = columns === undefined ? columnsof(data) : arrayify(columns);
  if (layout === undefined) layout = columns.length &gt;= 12 ? &quot;auto&quot; : &quot;fixed&quot;;
  format = formatof(format, data, columns, locale);
  align = alignof(align, data, columns);

  let array = [];
  let index = [];
  let iterator = data[Symbol.iterator]();
  let iterindex = 0;
  let N = lengthof(data); // total number of rows (if known)
  let n = minlengthof(rows * 2); // number of currently-shown rows

  // Defer materializing index and data arrays until needed.
  function materialize() {
    if (iterindex &gt;= 0) {
      iterindex = iterator = undefined;
      index = Uint32Array.from(array = arrayify(data), (_, i) =&gt; i);
      N = index.length;
    }
  }

  function minlengthof(length) {
    length = Math.floor(length);
    if (N !== undefined) return Math.min(N, length);
    if (length &lt;= iterindex) return length;
    while (length &gt; iterindex) {
      const {done, value} = iterator.next();
      if (done) return N = iterindex;
      index.push(iterindex++);
      array.push(value);
    }
    return iterindex;
  }

  let currentSortHeader = null, currentReverse = false;
  let selected = new Set();
  let anchor = null, head = null;

  const tbody = html`&lt;tbody&gt;`;
  const tr = html`&lt;tr&gt;&lt;td&gt;&lt;input type=${multiple ? &quot;checkbox&quot; : &quot;radio&quot;} name=${multiple ? null : &quot;radio&quot;}&gt;&lt;/td&gt;${columns.map(() =&gt; html`&lt;td&gt;`)}`;
  const theadr = html`&lt;tr&gt;&lt;th&gt;&lt;input type=checkbox onclick=${reselectAll} disabled=${!multiple}&gt;&lt;/th&gt;${columns.map((column) =&gt; html`&lt;th title=${column} onclick=${event =&gt; resort(event, column)}&gt;&lt;span&gt;&lt;/span&gt;${header &amp;&amp; column in header ? header[column] : column}&lt;/th&gt;`)}&lt;/tr&gt;`;
  root.appendChild(html.fragment`&lt;table style=${{tableLayout: layout}}&gt;
  &lt;thead&gt;${minlengthof(1) || columns.length ? theadr : null}&lt;/thead&gt;
  ${tbody}
&lt;/table&gt;
&lt;style&gt;${columns.map((column, i) =&gt; {
  const rules = [];
  if (align[column] != null) rules.push(`text-align:${align[column]}`);
  if (width[column] != null) rules.push(`width:${length(width[column])}`);
  if (rules.length) return `#${id} tr&gt;:nth-child(${i + 2}){${rules.join(&quot;;&quot;)}}`;
}).filter(identity).join(&quot;\n&quot;)}&lt;/style&gt;`);
  function appendRows(i, j) {
    if (iterindex === i) {
      for (; i &lt; j; ++i) {
        appendRow(iterator.next().value, i);
      }
      iterindex = j;
    } else {
      for (let k; i &lt; j; ++i) {
        k = index[i];
        appendRow(array[k], k);
      }
    }
  }

  function appendRow(d, i) {
    const itr = tr.cloneNode(true);
    const input = inputof(itr);
    input.onclick = reselect;
    input.checked = selected.has(i);
    input.value = i;
    if (d != null) for (let j = 0; j &lt; columns.length; ++j) {
      let column = columns[j];
      let value = d[column];
      if (!defined(value)) continue;
      value = format[column](value, i, data);
      if (!(value instanceof Node)) value = document.createTextNode(value);
      itr.childNodes[j + 1].appendChild(value);
    }
    tbody.append(itr);
  }

  function unselect(i) {
    materialize();
    let j = index.indexOf(i);
    if (j &lt; tbody.childNodes.length) {
      const tr = tbody.childNodes[j];
      inputof(tr).checked = false;
    }
    selected.delete(i);
  }

  function select(i) {
    materialize();
    let j = index.indexOf(i);
    if (j &lt; tbody.childNodes.length) {
      const tr = tbody.childNodes[j];
      inputof(tr).checked = true;
    }
    selected.add(i);
  }

  function* range(i, j) {
    materialize();
    i = index.indexOf(i), j = index.indexOf(j);
    if (i &lt; j) while (i &lt;= j) yield index[i++];
    else while (j &lt;= i) yield index[j++];
  }

  function first(set) {
    return set[Symbol.iterator]().next().value;
  }

  function reselectAll(event) {
    materialize();
    if (this.checked) {
      selected = new Set(index);
      for (const tr of tbody.childNodes) {
        inputof(tr).checked = true;
      }
    } else {
      for (let i of selected) unselect(i);
      anchor = head = null;
      if (event.detail) event.currentTarget.blur();
    }
    reinput();
  }

  function reselect(event) {
    materialize();
    let i = +this.value;
    if (!multiple) {
      for (let i of selected) unselect(i);
      select(i);
    } else if (event.shiftKey) {
      if (anchor === null) anchor = selected.size ? first(selected) : index[0];
      else for (let i of range(anchor, head)) unselect(i);
      head = i;
      for (let i of range(anchor, head)) select(i);
    } else {
      anchor = head = i;
      if (selected.has(i)) {
        unselect(i);
        anchor = head = null;
        if (event.detail) event.currentTarget.blur();
      } else {
        select(i);
      }
    }
    reinput();
  }

  function resort(event, column) {
    materialize();
    const th = event.currentTarget;
    let compare;
    if (currentSortHeader === th &amp;&amp; event.metaKey) {
      orderof(currentSortHeader).textContent = &quot;&quot;;
      currentSortHeader = null;
      currentReverse = false;
      compare = ascending;
    } else {
      if (currentSortHeader === th) {
        currentReverse = !currentReverse;
      } else {
        if (currentSortHeader) {
          orderof(currentSortHeader).textContent = &quot;&quot;;
        }
        currentSortHeader = th;
        currentReverse = event.altKey;
      }
      const order = currentReverse ? descending : ascending;
      compare = (a, b) =&gt; order(array[a][column], array[b][column]);
      orderof(th).textContent = currentReverse ? &quot;▾&quot;  : &quot;▴&quot;;
    }
    index.sort(compare);
    selected = new Set(Array.from(selected).sort(compare));
    root.scrollTo(root.scrollLeft, 0);
    while (tbody.firstChild) tbody.firstChild.remove();
    appendRows(0, n = minlengthof(rows * 2));
    anchor = head = null;
    reinput();
  }

  function reinput() {
    const check = inputof(theadr);
    check.disabled = !multiple &amp;&amp; !selected.size;
    check.indeterminate = multiple &amp;&amp; selected.size &amp;&amp; selected.size !== N; // assume materalized!
    check.checked = selected.size;
    value = undefined; // lazily computed
  }

  root.addEventListener(&quot;scroll&quot;, () =&gt; {
    if (root.scrollHeight - root.scrollTop &lt; rows * rowHeight * 1.5 &amp;&amp; n &lt; minlengthof(n + 1)) {
      appendRows(n, n = minlengthof(n + rows));
    }
  });

  if (sort === undefined &amp;&amp; reverse) {
    materialize();
    index.reverse();
  }

  if (value !== undefined) {
    materialize();
    if (multiple) {
      const values = new Set(value);
      selected = new Set(index.filter(i =&gt; values.has(array[i])));
    } else {
      const i = array.indexOf(value);
      selected = i &lt; 0 ? new Set() : new Set([i]);
    }
    reinput();
  }

  if (minlengthof(1)) {
    appendRows(0, n);
  } else {
    tbody.append(html`&lt;tr&gt;${columns.length ? html`&lt;td&gt;` : null}&lt;td rowspan=${columns.length} style=&quot;padding-left: var(--length3); font-style: italic;&quot;&gt;No results.&lt;/td&gt;&lt;/tr&gt;`);
  }

  if (sort !== undefined) {
    let i = columns.indexOf(sort);
    if (i &gt;= 0) {
      if (reverse) currentSortHeader = theadr.childNodes[i + 1];
      resort({currentTarget: theadr.childNodes[i + 1]}, columns[i]);
    }
  }

  return Object.defineProperty(root, &quot;value&quot;, {
    get() {
      if (value === undefined) {
        materialize();
        if (multiple) {
          value = Array.from(required &amp;&amp; selected.size === 0 ? index : selected, i =&gt; array[i]);
          value.columns = columns;
        } else if (selected.size) {
          const [i] = selected;
          value = array[i];
        } else {
          value = null;
        }
      }
      return value;
    },
    set(v) {
      materialize();
      if (multiple) {
        const values = new Set(v);
        const selection = new Set(index.filter(i =&gt; values.has(array[i])));
        for (const i of selected) if (!selection.has(i)) unselect(i);
        for (const i of selection) if (!selected.has(i)) select(i);
      } else {
        const i = array.indexOf(v);
        selected = i &lt; 0 ? new Set() : new Set([i]);
      }
      value = undefined; // lazily computed
    }
  });
}

function inputof(tr) {
  return tr.firstChild.firstChild;
}

function orderof(th) {
  return th.firstChild;
}

function formatof(base = {}, data, columns, locale) {
  const format = Object.create(null);
  for (const column of columns) {
    if (column in base) {
      format[column] = base[column];
      continue;
    }
    switch (type(data, column)) {
      case &quot;number&quot;: format[column] = formatLocaleNumber(locale); break;
      case &quot;date&quot;: format[column] = formatDate; break;
      default: format[column] = formatLocaleAuto(locale); break;
    }
  }
  return format;
}

function alignof(base = {}, data, columns) {
  const align = Object.create(null);
  for (const column of columns) {
    if (column in base) {
      align[column] = base[column];
    } else if (type(data, column) === &quot;number&quot;) {
      align[column] = &quot;right&quot;;
    }
  }
  return align;
}

function type(data, column) {
  for (const d of data) {
    if (d == null) continue;
    const value = d[column];
    if (value == null) continue;
    if (typeof value === &quot;number&quot;) return &quot;number&quot;;
    if (value instanceof Date) return &quot;date&quot;;
    return;
  }
}

function lengthof(data) {
  if (typeof data.length === &quot;number&quot;) return data.length; // array or array-like
  if (typeof data.size === &quot;number&quot;) return data.size; // map, set
  if (typeof data.numRows === &quot;function&quot;) return data.numRows(); // arquero
}

function columnsof(data) {
  const columns = new Set();
  for (const row of data) {
    for (const name in row) {
      columns.add(name);
    }
  }
  return Array.from(columns);
}
</pre>,<h4>text.js</h4>
        <pre>import {html} from &quot;htl&quot;;
import {maybeWidth} from &quot;./css.js&quot;;
import {maybeDatalist} from &quot;./datalist.js&quot;;
import {checkValidity, dispatchInput, preventDefault} from &quot;./event.js&quot;;
import {stringify} from &quot;./format.js&quot;;
import {maybeLabel} from &quot;./label.js&quot;;

export function createText(form, input, value, {
  validate = checkValidity,
  submit
} = {}, {
  get = (input) =&gt; input.value,
  set = (input, value) =&gt; input.value = stringify(value),
  same = (input, value) =&gt; input.value === value,
  after = (button) =&gt; input.after(button)
} = {}) {
  submit = submit === true ? &quot;Submit&quot; : submit || null;
  const button = submit ? html`&lt;button type=submit disabled&gt;${submit}` : null;
  if (submit) after(button);
  set(input, value);
  value = validate(input) ? get(input) : undefined;
  form.addEventListener(&quot;submit&quot;, onsubmit);
  input.oninput = oninput;
  function update() {
    if (validate(input)) {
      value = get(input);
      return true;
    }
  }
  function onsubmit(event) {
    preventDefault(event);
    if (submit) {
      if (update()) {
        button.disabled = true;
        dispatchInput(event);
      } else {
        input.reportValidity();
      }
    }
  }
  function oninput(event) {
    if (submit) {
      button.disabled = same(input, value);
      event.stopPropagation();
    } else if (!update()) {
      event.stopPropagation();
    }
  }
  return Object.defineProperty(form, &quot;value&quot;, {
    get() {
      return value;
    },
    set(v) {
      set(input, v);
      update();
    }
  });
}

export function text({
  label,
  value = &quot;&quot;,
  type = &quot;text&quot;,
  placeholder,
  pattern,
  spellcheck,
  autocomplete,
  autocapitalize,
  min,
  max,
  minlength,
  maxlength,
  required = minlength &gt; 0,
  datalist,
  readonly,
  disabled,
  width,
  ...options
} = {}) {
  const [list, listId] = maybeDatalist(datalist);
  const input = html`&lt;input
    type=${type}
    name=text
    list=${listId}
    readonly=${readonly}
    disabled=${disabled}
    required=${required}
    min=${min}
    max=${max}
    minlength=${minlength}
    maxlength=${maxlength}
    pattern=${pattern}
    spellcheck=${truefalse(spellcheck)}
    autocomplete=${onoff(autocomplete)}
    autocapitalize=${onoff(autocapitalize)}
    placeholder=${placeholder}
  &gt;`;
  const form = html`&lt;form class=__ns__ style=${maybeWidth(width)}&gt;
    ${maybeLabel(label, input)}&lt;div class=__ns__-input&gt;
      ${input}
    &lt;/div&gt;${list}
  &lt;/form&gt;`;
  return createText(form, input, value, options);
}

export function email(options) {
  return text({...options, type: &quot;email&quot;});
}

export function tel(options) {
  return text({...options, type: &quot;tel&quot;});
}

export function url(options) {
  return text({...options, type: &quot;url&quot;});
}

export function password(options) {
  return text({...options, type: &quot;password&quot;});
}

// Hypertext Literal will normally drop an attribute if its value is exactly
// false, but for these attributes (e.g., spellcheck), we actually want the
// false to be stringified as the attribute value.
export function truefalse(value) {
  return value == null ? null : `${value}`;
}

// For boolean attributes that support “on” and “off”, this maps true to “on”
// and false to “off”. Any other value (if not nullish) is assumed to be a
// string, such as autocapitalize=sentences.
export function onoff(value) {
  return value == null ? null : `${value === false ? &quot;off&quot; : value === true ? &quot;on&quot; : value}`;
}
</pre>,<h4>textarea.js</h4>
        <pre>import {html} from &quot;htl&quot;;
import {maybeWidth} from &quot;./css.js&quot;;
import {bubbles} from &quot;./event.js&quot;;
import {maybeLabel} from &quot;./label.js&quot;;
import {createText, onoff, truefalse} from &quot;./text.js&quot;;

export function textarea({
  value = &quot;&quot;,
  label,
  placeholder,
  spellcheck,
  autocomplete,
  autocapitalize,
  rows = 3,
  minlength,
  maxlength,
  required = minlength &gt; 0,
  readonly,
  disabled,
  monospace = false,
  resize = rows &lt; 12,
  width,
  ...options
} = {}) {
  const input = html`&lt;textarea
    name=text
    readonly=${readonly}
    disabled=${disabled}
    required=${required}
    rows=${rows}
    minlength=${minlength}
    maxlength=${maxlength}
    spellcheck=${truefalse(spellcheck)}
    autocomplete=${onoff(autocomplete)}
    autocapitalize=${onoff(autocapitalize)}
    placeholder=${placeholder}
    onkeydown=${onkeydown}
    style=${{
      width,
      fontFamily: monospace ? &quot;var(--monospace, monospace)&quot; : null,
      resize: resize ? null : &quot;none&quot;
    }}
  &gt;`;
  const form = html`&lt;form class=&quot;__ns__ __ns__-textarea&quot; style=${maybeWidth(width)}&gt;
    ${maybeLabel(label, input)}&lt;div&gt;
      ${input}
    &lt;/div&gt;
  &lt;/form&gt;`;
  function onkeydown(event) {
    if (options.submit &amp;&amp; event.key === &quot;Enter&quot; &amp;&amp; (event.metaKey || event.ctrlKey)) {
      return form.dispatchEvent(new Event(&quot;submit&quot;, bubbles));
    }
  }
  return createText(form, input, value, options);
}
</pre>
      </div>

</body>
</html>