<html>
<title>cli</title>
<style>
h1, h2, h3, h4, h5, h6 { margin-bottom: 1rem; page-break-before: always; }
h6 { font-size: 1rem; }
h5 { font-size: 2rem; }
h4 { font-size: 4rem; }
h3 { font-size: 8rem; }
h2 { font-size: 16rem; }
h1 { font-size: 32rem; }
</style>
<body>

<h1>cli</h1><h3>tsconfig.json</h3>
        <pre>{
  &quot;$schema&quot;: &quot;https://json.schemastore.org/tsconfig&quot;,
  &quot;display&quot;: &quot;Node LTS&quot;,
  &quot;_version&quot;: &quot;18.1.0&quot;,
  &quot;compilerOptions&quot;: {
    &quot;noImplicitAny&quot;: false,
    &quot;lib&quot;: [&quot;es2023&quot;],
    &quot;module&quot;: &quot;node16&quot;,
    &quot;target&quot;: &quot;es2022&quot;,
    &quot;strict&quot;: true,
    &quot;esModuleInterop&quot;: true,
    &quot;skipLibCheck&quot;: true,
    &quot;forceConsistentCasingInFileNames&quot;: true,
    &quot;moduleResolution&quot;: &quot;node16&quot;,
    &quot;resolveJsonModule&quot;: true
  }
}
</pre><h2>test</h2><h3>output</h3><h5>yaml-frontmatter.json</h5>
        <pre>{
  &quot;data&quot;: {
    &quot;title&quot;: &quot;YAML&quot;,
    &quot;style&quot;: [
      &quot;one&quot;,
      &quot;two&quot;
    ]
  },
  &quot;title&quot;: &quot;YAML&quot;,
  &quot;files&quot;: [],
  &quot;imports&quot;: [],
  &quot;pieces&quot;: [
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [],
      &quot;html&quot;: &quot;&lt;h1 id=\&quot;yaml-frontmatter\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;a class=\&quot;observablehq-header-anchor\&quot; href=\&quot;#yaml-frontmatter\&quot;&gt;YAML frontmatter&lt;/a&gt;&lt;/h1&gt;\n&quot;
    },
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [],
      &quot;html&quot;: &quot;&lt;p&gt;This page has some YAML configuration.&lt;/p&gt;\n&quot;
    }
  ],
  &quot;cells&quot;: []
}</pre><h5>wellformed-block.json</h5>
        <pre>{
  &quot;data&quot;: null,
  &quot;title&quot;: &quot;Well-formed block&quot;,
  &quot;files&quot;: [],
  &quot;imports&quot;: [],
  &quot;pieces&quot;: [
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [],
      &quot;html&quot;: &quot;&lt;h1 id=\&quot;well-formed-block\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;a class=\&quot;observablehq-header-anchor\&quot; href=\&quot;#well-formed-block\&quot;&gt;Well-formed block&lt;/a&gt;&lt;/h1&gt;\n&quot;
    },
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [],
      &quot;html&quot;: &quot;&lt;div&gt;\n  &lt;div&gt;content&lt;/div&gt;\n&lt;/div&gt;\n&quot;
    }
  ],
  &quot;cells&quot;: []
}</pre><h5>var.js</h5>
        <pre>define({id: &quot;0&quot;, outputs: [&quot;foo&quot;], body: () =&gt; {
var foo = 1;
return {foo};
}});
</pre><h5>try-catch.js</h5>
        <pre>define({id: &quot;0&quot;, inputs: [&quot;y&quot;,&quot;display&quot;], body: (y,display) =&gt; {
try {
  let [x] = y;
  x++;
  display(x);
} catch (e) {
  display(e);
}
}});
</pre><h5>top-level-yield.js</h5>
        <pre>define({id: &quot;0&quot;, body: () =&gt; { throw new SyntaxError(&quot;The keyword &apos;yield&apos; is reserved (1:0)&quot;); }});
</pre><h5>top-level-return.js</h5>
        <pre>define({id: &quot;0&quot;, body: () =&gt; { throw new SyntaxError(&quot;&apos;return&apos; outside of function (1:0)&quot;); }});
</pre><h5>this.js</h5>
        <pre>define({id: &quot;0&quot;, inputs: [&quot;display&quot;], body: (display) =&gt; {
display((
this
))
}});
</pre><h5>tex-expression.json</h5>
        <pre>{
  &quot;data&quot;: null,
  &quot;title&quot;: &quot;Hello, &quot;,
  &quot;files&quot;: [],
  &quot;imports&quot;: [],
  &quot;pieces&quot;: [
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [
        &quot;16447e3a&quot;
      ],
      &quot;html&quot;: &quot;&lt;h1 id=\&quot;hello%2C\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;a class=\&quot;observablehq-header-anchor\&quot; href=\&quot;#hello%2C\&quot;&gt;Hello, &lt;span id=\&quot;cell-16447e3a\&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/h1&gt;\n&quot;
    },
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [
        &quot;828eccc1&quot;
      ],
      &quot;html&quot;: &quot;&lt;p&gt;My favorite equation is &lt;span id=\&quot;cell-828eccc1\&quot;&gt;&lt;/span&gt;.&lt;/p&gt;\n&quot;
    }
  ],
  &quot;cells&quot;: [
    {
      &quot;type&quot;: &quot;cell&quot;,
      &quot;id&quot;: &quot;16447e3a&quot;,
      &quot;inputs&quot;: [
        &quot;tex&quot;,
        &quot;display&quot;
      ],
      &quot;inline&quot;: true,
      &quot;body&quot;: &quot;(tex,display) =&gt; {\ndisplay((\ntex`\\KaTeX`\n))\n}&quot;
    },
    {
      &quot;type&quot;: &quot;cell&quot;,
      &quot;id&quot;: &quot;828eccc1&quot;,
      &quot;inputs&quot;: [
        &quot;tex&quot;,
        &quot;display&quot;
      ],
      &quot;inline&quot;: true,
      &quot;body&quot;: &quot;(tex,display) =&gt; {\ndisplay((\ntex`E = mc^2`\n))\n}&quot;
    }
  ]
}</pre><h5>template-expression.json</h5>
        <pre>{
  &quot;data&quot;: null,
  &quot;title&quot;: null,
  &quot;files&quot;: [],
  &quot;imports&quot;: [],
  &quot;pieces&quot;: [
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [
        &quot;12fd0aea&quot;
      ],
      &quot;html&quot;: &quot;&lt;p&gt;&lt;span id=\&quot;cell-12fd0aea\&quot;&gt;&lt;/span&gt;&lt;/p&gt;\n&quot;
    }
  ],
  &quot;cells&quot;: [
    {
      &quot;type&quot;: &quot;cell&quot;,
      &quot;id&quot;: &quot;12fd0aea&quot;,
      &quot;inputs&quot;: [
        &quot;display&quot;
      ],
      &quot;inline&quot;: true,
      &quot;body&quot;: &quot;(display) =&gt; {\ndisplay((\n`}&apos;\&quot;`\n))\n}&quot;
    }
  ]
}</pre><h5>static-import.js</h5>
        <pre>define({id: &quot;0&quot;, inputs: [&quot;display&quot;], outputs: [&quot;foo&quot;], files: [{&quot;name&quot;:&quot;./bar.js&quot;,&quot;mimeType&quot;:&quot;application/javascript&quot;}], body: async (display) =&gt; {
const {foo} = await import(&quot;/_file/bar.js&quot;);

display(foo);
return {foo};
}});
</pre><h5>single-quote-expression.json</h5>
        <pre>{
  &quot;data&quot;: null,
  &quot;title&quot;: null,
  &quot;files&quot;: [],
  &quot;imports&quot;: [],
  &quot;pieces&quot;: [
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [
        &quot;08961c06&quot;
      ],
      &quot;html&quot;: &quot;&lt;p&gt;&lt;span id=\&quot;cell-08961c06\&quot;&gt;&lt;/span&gt;&lt;/p&gt;\n&quot;
    }
  ],
  &quot;cells&quot;: [
    {
      &quot;type&quot;: &quot;cell&quot;,
      &quot;id&quot;: &quot;08961c06&quot;,
      &quot;inputs&quot;: [
        &quot;display&quot;
      ],
      &quot;inline&quot;: true,
      &quot;body&quot;: &quot;(display) =&gt; {\ndisplay((\n&apos;}\&quot;&apos;\n))\n}&quot;
    }
  ]
}</pre><h5>semicolons.js</h5>
        <pre>define({id: &quot;0&quot;, body: () =&gt; {
;;
}});
</pre><h5>semicolon.js</h5>
        <pre>define({id: &quot;0&quot;, body: () =&gt; {
;
}});
</pre><h5>script-expression.json</h5>
        <pre>{
  &quot;data&quot;: null,
  &quot;title&quot;: &quot;Script expression&quot;,
  &quot;files&quot;: [],
  &quot;imports&quot;: [],
  &quot;pieces&quot;: [
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [],
      &quot;html&quot;: &quot;&lt;h1 id=\&quot;script-expression\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;a class=\&quot;observablehq-header-anchor\&quot; href=\&quot;#script-expression\&quot;&gt;Script expression&lt;/a&gt;&lt;/h1&gt;\n&quot;
    },
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [],
      &quot;html&quot;: &quot;&lt;script type=\&quot;module\&quot;&gt;\n\nconst subject = \&quot;world\&quot;;\nconst message = `Hello, ${subject}!`;\n\n&lt;/script&gt;\n&quot;
    }
  ],
  &quot;cells&quot;: []
}</pre><h5>reserved-local.js</h5>
        <pre>define({id: &quot;0&quot;, body: () =&gt; { throw new SyntaxError(&quot;Global &apos;Array&apos; cannot be redefined (1:6)&quot;); }});
</pre><h5>reserved-function.js</h5>
        <pre>define({id: &quot;0&quot;, body: () =&gt; { throw new SyntaxError(&quot;Global &apos;Array&apos; cannot be redefined (1:9)&quot;); }});
</pre><h5>optional-chaining.js</h5>
        <pre>define({id: &quot;0&quot;, inputs: [&quot;adventurer&quot;], outputs: [&quot;dogName&quot;], body: (adventurer) =&gt; {
const dogName = adventurer.dog?.name;
return {dogName};
}});
</pre><h5>object-literal.js</h5>
        <pre>define({id: &quot;0&quot;, inputs: [&quot;display&quot;], body: (display) =&gt; {
display((
{a: 1}
))
}});
</pre><h5>nullish-coalescing.js</h5>
        <pre>define({id: &quot;0&quot;, outputs: [&quot;foo&quot;], body: () =&gt; {
const foo = null ?? &quot;default string&quot;;
return {foo};
}});
</pre><h5>markdown-in-html.json</h5>
        <pre>{
  &quot;data&quot;: null,
  &quot;title&quot;: &quot;Markdown in HTML&quot;,
  &quot;files&quot;: [],
  &quot;imports&quot;: [],
  &quot;pieces&quot;: [
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [],
      &quot;html&quot;: &quot;&lt;h1 id=\&quot;markdown-in-html\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;a class=\&quot;observablehq-header-anchor\&quot; href=\&quot;#markdown-in-html\&quot;&gt;Markdown in HTML&lt;/a&gt;&lt;/h1&gt;\n&quot;
    },
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [],
      &quot;html&quot;: &quot;&lt;div&gt;\n  # Hello\n&lt;/div&gt;\n&quot;
    }
  ],
  &quot;cells&quot;: []
}</pre><h5>malformed-block.json</h5>
        <pre>{
  &quot;data&quot;: null,
  &quot;title&quot;: &quot;Malformed block&quot;,
  &quot;files&quot;: [],
  &quot;imports&quot;: [],
  &quot;pieces&quot;: [
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [],
      &quot;html&quot;: &quot;&lt;h1 id=\&quot;malformed-block\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;a class=\&quot;observablehq-header-anchor\&quot; href=\&quot;#malformed-block\&quot;&gt;Malformed block&lt;/a&gt;&lt;/h1&gt;\n&quot;
    },
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [],
      &quot;html&quot;: &quot;&lt;div&gt;\n&lt;/div&gt;&quot;
    },
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [],
      &quot;html&quot;: &quot;  &lt;div&gt;content&lt;/div&gt;\n&quot;
    },
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [],
      &quot;html&quot;: &quot;&lt;span&gt;\n&lt;/span&gt;&quot;
    }
  ],
  &quot;cells&quot;: []
}</pre><h5>logical-assignment.js</h5>
        <pre>define({id: &quot;0&quot;, outputs: [&quot;a&quot;,&quot;b&quot;], body: () =&gt; {
let a = null;
let b = false;
a ||= b;
return {a,b};
}});
</pre><h5>local-this.js</h5>
        <pre>define({id: &quot;0&quot;, body: () =&gt; { throw new SyntaxError(&quot;Unexpected keyword &apos;this&apos; (1:6)&quot;); }});
</pre><h5>local-fetch.json</h5>
        <pre>{
  &quot;data&quot;: null,
  &quot;title&quot;: &quot;Local fetch&quot;,
  &quot;files&quot;: [
    {
      &quot;name&quot;: &quot;./local-fetch.md&quot;,
      &quot;mimeType&quot;: &quot;text/markdown&quot;
    }
  ],
  &quot;imports&quot;: [],
  &quot;pieces&quot;: [
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [],
      &quot;html&quot;: &quot;&lt;h1 id=\&quot;local-fetch\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;a class=\&quot;observablehq-header-anchor\&quot; href=\&quot;#local-fetch\&quot;&gt;Local fetch&lt;/a&gt;&lt;/h1&gt;\n&quot;
    },
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [
        &quot;06e1c6cd&quot;
      ],
      &quot;html&quot;: &quot;&lt;div id=\&quot;cell-06e1c6cd\&quot; class=\&quot;observablehq observablehq--block\&quot;&gt;&lt;/div&gt;\n&quot;
    }
  ],
  &quot;cells&quot;: [
    {
      &quot;type&quot;: &quot;cell&quot;,
      &quot;id&quot;: &quot;06e1c6cd&quot;,
      &quot;inputs&quot;: [
        &quot;display&quot;
      ],
      &quot;files&quot;: [
        {
          &quot;name&quot;: &quot;./local-fetch.md&quot;,
          &quot;mimeType&quot;: &quot;text/markdown&quot;
        }
      ],
      &quot;body&quot;: &quot;(display) =&gt; {\ndisplay((\nfetch(\&quot;./_file/local-fetch.md\&quot;)\n))\n}&quot;
    }
  ]
}</pre><h5>local-const.js</h5>
        <pre>define({id: &quot;0&quot;, body: () =&gt; {
{
  const x = 1;
}
}});
</pre><h5>local-arguments.js</h5>
        <pre>define({id: &quot;0&quot;, body: () =&gt; { throw new SyntaxError(&quot;Binding arguments in strict mode (1:6)&quot;); }});
</pre><h5>lets.js</h5>
        <pre>define({id: &quot;0&quot;, outputs: [&quot;x&quot;,&quot;y&quot;], body: () =&gt; {
let x = 1, y = 2;
return {x,y};
}});
</pre><h5>let.js</h5>
        <pre>define({id: &quot;0&quot;, outputs: [&quot;x&quot;], body: () =&gt; {
let x = 1;
return {x};
}});
</pre><h5>let-increment.js</h5>
        <pre>define({id: &quot;0&quot;, outputs: [&quot;x&quot;], body: () =&gt; {
let x = 0;
++x;
x++;
return {x};
}});
</pre><h5>let-assign.js</h5>
        <pre>define({id: &quot;0&quot;, outputs: [&quot;x&quot;], body: () =&gt; {
let x;
x = 1;
x = 2;
return {x};
}});
</pre><h5>legal-arguments.js</h5>
        <pre>define({id: &quot;0&quot;, outputs: [&quot;foo&quot;], body: () =&gt; {
function foo() { return arguments.length; }
return {foo};
}});
</pre><h5>input.js</h5>
        <pre>define({id: &quot;0&quot;, inputs: [&quot;view&quot;,&quot;Inputs&quot;], outputs: [&quot;name&quot;], body: (view,Inputs) =&gt; {
const name = view(Inputs.text({label: &quot;Name&quot;}));
return {name};
}});
</pre><h5>inline-expression.json</h5>
        <pre>{
  &quot;data&quot;: null,
  &quot;title&quot;: null,
  &quot;files&quot;: [],
  &quot;imports&quot;: [],
  &quot;pieces&quot;: [
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [
        &quot;6212702c&quot;
      ],
      &quot;html&quot;: &quot;&lt;p&gt;&lt;span&gt;&lt;span id=\&quot;cell-6212702c\&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;\n&quot;
    }
  ],
  &quot;cells&quot;: [
    {
      &quot;type&quot;: &quot;cell&quot;,
      &quot;id&quot;: &quot;6212702c&quot;,
      &quot;inputs&quot;: [
        &quot;display&quot;
      ],
      &quot;inline&quot;: true,
      &quot;body&quot;: &quot;(display) =&gt; {\ndisplay((\n1 + 2\n))\n}&quot;
    }
  ]
}</pre><h5>identifier.js</h5>
        <pre>define({id: &quot;0&quot;, inputs: [&quot;foo&quot;,&quot;display&quot;], body: (foo,display) =&gt; {
display((
foo
))
}});
</pre><h5>hello-world.json</h5>
        <pre>{
  &quot;data&quot;: null,
  &quot;title&quot;: &quot;Hello, world!&quot;,
  &quot;files&quot;: [],
  &quot;imports&quot;: [],
  &quot;pieces&quot;: [
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [],
      &quot;html&quot;: &quot;&lt;h1 id=\&quot;hello%2C-world!\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;a class=\&quot;observablehq-header-anchor\&quot; href=\&quot;#hello%2C-world!\&quot;&gt;Hello, world!&lt;/a&gt;&lt;/h1&gt;\n&quot;
    },
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [],
      &quot;html&quot;: &quot;&lt;p&gt;This is a test.&lt;/p&gt;\n&quot;
    }
  ],
  &quot;cells&quot;: []
}</pre><h5>heading-expression.json</h5>
        <pre>{
  &quot;data&quot;: null,
  &quot;title&quot;: null,
  &quot;files&quot;: [],
  &quot;imports&quot;: [],
  &quot;pieces&quot;: [
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [
        &quot;6212702c&quot;
      ],
      &quot;html&quot;: &quot;&lt;h1 tabindex=\&quot;-1\&quot;&gt;&lt;a class=\&quot;observablehq-header-anchor\&quot; href=\&quot;#\&quot;&gt;&lt;span id=\&quot;cell-6212702c\&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/h1&gt;\n&quot;
    }
  ],
  &quot;cells&quot;: [
    {
      &quot;type&quot;: &quot;cell&quot;,
      &quot;id&quot;: &quot;6212702c&quot;,
      &quot;inputs&quot;: [
        &quot;display&quot;
      ],
      &quot;inline&quot;: true,
      &quot;body&quot;: &quot;(display) =&gt; {\ndisplay((\n1 + 2\n))\n}&quot;
    }
  ]
}</pre><h5>generator.js</h5>
        <pre>define({id: &quot;0&quot;, outputs: [&quot;x&quot;], body: () =&gt; {
const x = (function*() {
  for (let i = 0; i &lt; 10; ++i) {
    yield i;
  }
})();
return {x};
}});
</pre><h5>generator-function.js</h5>
        <pre>define({id: &quot;0&quot;, outputs: [&quot;foo&quot;], body: () =&gt; {
function* foo() {
  yield 42;
}
return {foo};
}});
</pre><h5>functions.js</h5>
        <pre>define({id: &quot;0&quot;, outputs: [&quot;add&quot;,&quot;subtract&quot;], body: () =&gt; {
function add(a, b) {
  return a + b;
}

function subtract(a, b) {
  return a - b;
}
return {add,subtract};
}});
</pre><h5>function.js</h5>
        <pre>define({id: &quot;0&quot;, outputs: [&quot;add&quot;], body: () =&gt; {
function add(a, b) {
  return a + b;
}
return {add};
}});
</pre><h5>for-await-of.js</h5>
        <pre>define({id: &quot;0&quot;, inputs: [&quot;foo&quot;], outputs: [&quot;values&quot;], body: async (foo) =&gt; {
const values = [];
for await (const value of foo()) values.push(value);
return {values};
}});
</pre><h5>fenced-code.json</h5>
        <pre>{
  &quot;data&quot;: null,
  &quot;title&quot;: &quot;Fenced code&quot;,
  &quot;files&quot;: [],
  &quot;imports&quot;: [],
  &quot;pieces&quot;: [
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [],
      &quot;html&quot;: &quot;&lt;h1 id=\&quot;fenced-code\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;a class=\&quot;observablehq-header-anchor\&quot; href=\&quot;#fenced-code\&quot;&gt;Fenced code&lt;/a&gt;&lt;/h1&gt;\n&quot;
    },
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [
        &quot;fe9e095e&quot;
      ],
      &quot;html&quot;: &quot;&lt;div&gt;&lt;div id=\&quot;cell-fe9e095e\&quot; class=\&quot;observablehq observablehq--block\&quot;&gt;&lt;/div&gt;\n&lt;pre&gt;&lt;code class=\&quot;language-js\&quot;&gt;&lt;span class=\&quot;hljs-keyword\&quot;&gt;function&lt;/span&gt; &lt;span class=\&quot;hljs-title function_\&quot;&gt;add&lt;/span&gt;(&lt;span class=\&quot;hljs-params\&quot;&gt;a, b&lt;/span&gt;) {\n  &lt;span class=\&quot;hljs-keyword\&quot;&gt;return&lt;/span&gt; a + b;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;&quot;
    }
  ],
  &quot;cells&quot;: [
    {
      &quot;type&quot;: &quot;cell&quot;,
      &quot;id&quot;: &quot;fe9e095e&quot;,
      &quot;outputs&quot;: [
        &quot;add&quot;
      ],
      &quot;body&quot;: &quot;() =&gt; {\nfunction add(a, b) {\n  return a + b;\n}\nreturn {add};\n}&quot;
    }
  ]
}</pre><h5>external-assignment.js</h5>
        <pre>define({id: &quot;0&quot;, body: () =&gt; { throw new SyntaxError(&quot;Assignment to external variable &apos;x&apos; (1:0)&quot;); }});
</pre><h5>expression.js</h5>
        <pre>define({id: &quot;0&quot;, inputs: [&quot;display&quot;], body: (display) =&gt; {
display((
1 + 2
))
}});
</pre><h5>expression-trailing-comment.js</h5>
        <pre>define({id: &quot;0&quot;, inputs: [&quot;display&quot;], body: (display) =&gt; {
display((
42 // Hello, comment.
))
}});
</pre><h5>expression-statement.js</h5>
        <pre>define({id: &quot;0&quot;, body: () =&gt; {
1 + 2;
}});
</pre><h5>expression-leading-comment.js</h5>
        <pre>define({id: &quot;0&quot;, inputs: [&quot;display&quot;], body: (display) =&gt; {
display((
// Hello, comment.
42
))
}});
</pre><h5>expression-extra.js</h5>
        <pre>define({id: &quot;0&quot;, body: () =&gt; { throw new SyntaxError(&quot;Unexpected token (1:4)&quot;); }});
</pre><h5>escaped-expression.json</h5>
        <pre>{
  &quot;data&quot;: null,
  &quot;title&quot;: null,
  &quot;files&quot;: [],
  &quot;imports&quot;: [],
  &quot;pieces&quot;: [
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [],
      &quot;html&quot;: &quot;&lt;p&gt;${1 + 2}&lt;/p&gt;\n&quot;
    }
  ],
  &quot;cells&quot;: []
}</pre><h5>empty.js</h5>
        <pre>define({id: &quot;0&quot;, body: () =&gt; {

}});
</pre><h5>embedded-expression.json</h5>
        <pre>{
  &quot;data&quot;: null,
  &quot;title&quot;: &quot;Embedded expression&quot;,
  &quot;files&quot;: [],
  &quot;imports&quot;: [],
  &quot;pieces&quot;: [
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [],
      &quot;html&quot;: &quot;&lt;h1 id=\&quot;embedded-expression\&quot; tabindex=\&quot;-1\&quot;&gt;&lt;a class=\&quot;observablehq-header-anchor\&quot; href=\&quot;#embedded-expression\&quot;&gt;Embedded expression&lt;/a&gt;&lt;/h1&gt;\n&quot;
    },
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [
        &quot;6212702c&quot;
      ],
      &quot;html&quot;: &quot;&lt;p&gt;One plus two is &lt;span id=\&quot;cell-6212702c\&quot;&gt;&lt;/span&gt;.&lt;/p&gt;\n&quot;
    }
  ],
  &quot;cells&quot;: [
    {
      &quot;type&quot;: &quot;cell&quot;,
      &quot;id&quot;: &quot;6212702c&quot;,
      &quot;inputs&quot;: [
        &quot;display&quot;
      ],
      &quot;inline&quot;: true,
      &quot;body&quot;: &quot;(display) =&gt; {\ndisplay((\n1 + 2\n))\n}&quot;
    }
  ]
}</pre><h5>dynamic-import.js</h5>
        <pre>define({id: &quot;0&quot;, outputs: [&quot;foo&quot;], files: [{&quot;name&quot;:&quot;./bar.js&quot;,&quot;mimeType&quot;:&quot;application/javascript&quot;}], body: async () =&gt; {
const foo = await import(&quot;/_file/bar.js&quot;);
return {foo};
}});
</pre><h5>double-quote-expression.json</h5>
        <pre>{
  &quot;data&quot;: null,
  &quot;title&quot;: null,
  &quot;files&quot;: [],
  &quot;imports&quot;: [],
  &quot;pieces&quot;: [
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [
        &quot;56e8b37a&quot;
      ],
      &quot;html&quot;: &quot;&lt;p&gt;&lt;span id=\&quot;cell-56e8b37a\&quot;&gt;&lt;/span&gt;&lt;/p&gt;\n&quot;
    }
  ],
  &quot;cells&quot;: [
    {
      &quot;type&quot;: &quot;cell&quot;,
      &quot;id&quot;: &quot;56e8b37a&quot;,
      &quot;inputs&quot;: [
        &quot;display&quot;
      ],
      &quot;inline&quot;: true,
      &quot;body&quot;: &quot;(display) =&gt; {\ndisplay((\n\&quot;}&apos;\&quot;\n))\n}&quot;
    }
  ]
}</pre><h5>dollar-expression.json</h5>
        <pre>{
  &quot;data&quot;: null,
  &quot;title&quot;: null,
  &quot;files&quot;: [],
  &quot;imports&quot;: [],
  &quot;pieces&quot;: [
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [
        &quot;6212702c&quot;
      ],
      &quot;html&quot;: &quot;&lt;p&gt;$&lt;span id=\&quot;cell-6212702c\&quot;&gt;&lt;/span&gt;&lt;/p&gt;\n&quot;
    }
  ],
  &quot;cells&quot;: [
    {
      &quot;type&quot;: &quot;cell&quot;,
      &quot;id&quot;: &quot;6212702c&quot;,
      &quot;inputs&quot;: [
        &quot;display&quot;
      ],
      &quot;inline&quot;: true,
      &quot;body&quot;: &quot;(display) =&gt; {\ndisplay((\n1 + 2\n))\n}&quot;
    }
  ]
}</pre><h5>default-initializer.js</h5>
        <pre>define({id: &quot;0&quot;, inputs: [&quot;x&quot;], outputs: [&quot;fun&quot;], body: (x) =&gt; {
function fun(foo = x) {}
return {fun};
}});
</pre><h5>databaseclient.json</h5>
        <pre>{
  &quot;data&quot;: null,
  &quot;title&quot;: null,
  &quot;files&quot;: [],
  &quot;imports&quot;: [],
  &quot;pieces&quot;: [
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [
        &quot;1e6b99bd&quot;
      ],
      &quot;html&quot;: &quot;&lt;div id=\&quot;cell-1e6b99bd\&quot; class=\&quot;observablehq observablehq--block\&quot;&gt;&lt;/div&gt;\n&quot;
    }
  ],
  &quot;cells&quot;: [
    {
      &quot;type&quot;: &quot;cell&quot;,
      &quot;id&quot;: &quot;1e6b99bd&quot;,
      &quot;inputs&quot;: [
        &quot;DatabaseClient&quot;
      ],
      &quot;outputs&quot;: [
        &quot;db&quot;
      ],
      &quot;databases&quot;: [
        {
          &quot;name&quot;: &quot;dwh-local-proxy&quot;
        }
      ],
      &quot;body&quot;: &quot;(DatabaseClient) =&gt; {\nconst db = DatabaseClient(\&quot;dwh-local-proxy\&quot;);\nreturn {db};\n}&quot;
    }
  ]
}</pre><h5>consts.js</h5>
        <pre>define({id: &quot;0&quot;, outputs: [&quot;x&quot;,&quot;y&quot;], body: () =&gt; {
const x = 1, y = 2;
return {x,y};
}});
</pre><h5>const.js</h5>
        <pre>define({id: &quot;0&quot;, outputs: [&quot;x&quot;], body: () =&gt; {
const x = 1;
return {x};
}});
</pre><h5>computed-property-name.js</h5>
        <pre>define({id: &quot;0&quot;, inputs: [&quot;field&quot;], outputs: [&quot;x&quot;], body: (field) =&gt; {
const x = ({[field]: value}) =&gt; value;
return {x};
}});
</pre><h5>comment.js</h5>
        <pre>define({id: &quot;0&quot;, body: () =&gt; {
// Hello, comment.
}});
</pre><h5>comma-expression.js</h5>
        <pre>define({id: &quot;0&quot;, inputs: [&quot;display&quot;], body: (display) =&gt; {
display((
1, 2
))
}});
</pre><h5>comma-comment.js</h5>
        <pre>define({id: &quot;0&quot;, body: () =&gt; { throw new SyntaxError(&quot;Unexpected token (2:0)&quot;); }});
</pre><h5>classes.js</h5>
        <pre>define({id: &quot;0&quot;, outputs: [&quot;Foo&quot;,&quot;Bar&quot;], body: () =&gt; {
class Foo {}
class Bar {}
return {Foo,Bar};
}});
</pre><h5>class.js</h5>
        <pre>define({id: &quot;0&quot;, outputs: [&quot;Foo&quot;], body: () =&gt; {
class Foo {}
return {Foo};
}});
</pre><h5>block.js</h5>
        <pre>define({id: &quot;0&quot;, inputs: [&quot;display&quot;], body: (display) =&gt; {
{
  display(42);
}
}});
</pre><h5>block-trailing-comment.js</h5>
        <pre>define({id: &quot;0&quot;, inputs: [&quot;display&quot;], body: (display) =&gt; {
{
  display(42);
}
// Hello, comment.
}});
</pre><h5>block-leading-comment.js</h5>
        <pre>define({id: &quot;0&quot;, inputs: [&quot;display&quot;], body: (display) =&gt; {
// Hello, comment.
{
  display(42);
}
}});
</pre><h5>block-expression.json</h5>
        <pre>{
  &quot;data&quot;: null,
  &quot;title&quot;: null,
  &quot;files&quot;: [],
  &quot;imports&quot;: [],
  &quot;pieces&quot;: [
    {
      &quot;type&quot;: &quot;html&quot;,
      &quot;id&quot;: &quot;&quot;,
      &quot;cellIds&quot;: [
        &quot;6212702c&quot;
      ],
      &quot;html&quot;: &quot;&lt;div&gt;&lt;span id=\&quot;cell-6212702c\&quot;&gt;&lt;/span&gt;&lt;/div&gt;\n&quot;
    }
  ],
  &quot;cells&quot;: [
    {
      &quot;type&quot;: &quot;cell&quot;,
      &quot;id&quot;: &quot;6212702c&quot;,
      &quot;inputs&quot;: [
        &quot;display&quot;
      ],
      &quot;inline&quot;: true,
      &quot;body&quot;: &quot;(display) =&gt; {\ndisplay((\n1 + 2\n))\n}&quot;
    }
  ]
}</pre><h5>bigint.js</h5>
        <pre>define({id: &quot;0&quot;, inputs: [&quot;foo&quot;,&quot;display&quot;], body: (foo,display) =&gt; {
display((
foo + 42n
))
}});
</pre><h5>bigint-zero.js</h5>
        <pre>define({id: &quot;0&quot;, inputs: [&quot;display&quot;], body: (display) =&gt; {
display((
0n
))
}});
</pre><h5>await.js</h5>
        <pre>define({id: &quot;0&quot;, inputs: [&quot;promise&quot;,&quot;display&quot;], body: async (promise,display) =&gt; {
display((
await promise
))
}});
</pre><h5>async-template-literal.js</h5>
        <pre>define({id: &quot;0&quot;, inputs: [&quot;md&quot;,&quot;promise&quot;,&quot;display&quot;], body: async (md,promise,display) =&gt; {
display((
md`${await promise}`
))
}});
</pre><h5>async-function.js</h5>
        <pre>define({id: &quot;0&quot;, outputs: [&quot;addAsync&quot;], body: () =&gt; {
async function addAsync(a, b) {
  return (await a) + (await b);
}
return {addAsync};
}});
</pre><h5>async-class.js</h5>
        <pre>define({id: &quot;0&quot;, outputs: [&quot;Foo&quot;], body: () =&gt; {
class Foo {
  async addAsync(a, b) {
    return (await a) + (await b);
  }
}
return {Foo};
}});
</pre><h5>async-arrow-function.js</h5>
        <pre>define({id: &quot;0&quot;, outputs: [&quot;addAsync&quot;], body: () =&gt; {
const addAsync = async (a, b) =&gt; (await a) + (await b);
return {addAsync};
}});
</pre><h5>anonymous-function.js</h5>
        <pre>define({id: &quot;0&quot;, inputs: [&quot;display&quot;], body: (display) =&gt; {
display((
function() { return 42; }
))
}});
</pre><h5>anonymous-class.js</h5>
        <pre>define({id: &quot;0&quot;, inputs: [&quot;display&quot;], body: (display) =&gt; {
display((
class {}
))
}});
</pre><h4>markdown-test.ts</h4>
        <pre>import assert from &quot;node:assert&quot;;
import {readdirSync, statSync} from &quot;node:fs&quot;;
import {readFile, unlink, writeFile} from &quot;node:fs/promises&quot;;
import {basename, join, resolve} from &quot;node:path&quot;;
import {isNodeError} from &quot;../src/error.js&quot;;
import {type ParseResult, parseMarkdown} from &quot;../src/markdown.js&quot;;
import deepEqual from &quot;fast-deep-equal&quot;;

describe(&quot;parseMarkdown(input)&quot;, () =&gt; {
  for (const name of readdirSync(&quot;./test/input&quot;)) {
    if (!name.endsWith(&quot;.md&quot;)) continue;
    const path = join(&quot;./test/input&quot;, name);
    if (!statSync(path).isFile()) continue;
    const only = name.startsWith(&quot;only.&quot;);
    const skip = name.startsWith(&quot;skip.&quot;);
    const outname = only || skip ? name.slice(5) : name;
    (only ? it.only : skip ? it.skip : it)(`test/input/${name}`, async () =&gt; {
      const snapshot = parseMarkdown(await readFile(path, &quot;utf8&quot;), &quot;test/input&quot;);
      let allequal = true;
      for (const ext of [&quot;html&quot;, &quot;json&quot;]) {
        const actual = ext === &quot;json&quot; ? jsonMeta(snapshot) : snapshot[ext];
        const outfile = resolve(&quot;./test/output&quot;, `${basename(outname, &quot;.md&quot;)}.${ext}`);
        const diffile = resolve(&quot;./test/output&quot;, `${basename(outname, &quot;.md&quot;)}-changed.${ext}`);
        let expected;

        try {
          expected = await readFile(outfile, &quot;utf8&quot;);
        } catch (error) {
          if (isNodeError(error) &amp;&amp; error.code === &quot;ENOENT&quot; &amp;&amp; process.env.CI !== &quot;true&quot;) {
            console.warn(`! generating ${outfile}`);
            await writeFile(outfile, actual, &quot;utf8&quot;);
            continue;
          } else {
            throw error;
          }
        }

        const equal = ext === &quot;json&quot; ? jsonEqual(expected, actual) : expected === actual;

        if (equal) {
          if (process.env.CI !== &quot;true&quot;) {
            try {
              await unlink(diffile);
              console.warn(`! deleted ${diffile}`);
            } catch (error) {
              if (!isNodeError(error) || error.code !== &quot;ENOENT&quot;) {
                throw error;
              }
            }
          }
        } else {
          allequal = false;
          console.warn(`! generating ${diffile}`);
          await writeFile(diffile, actual, &quot;utf8&quot;);
        }
      }
      assert.ok(allequal, `${name} must match snapshot`);
    });
  }
});

function jsonMeta({html, ...rest}: ParseResult): string {
  return JSON.stringify(rest, null, 2);
}

function jsonEqual(a: string, b: string): boolean {
  return deepEqual(JSON.parse(a), JSON.parse(b));
}
</pre><h4>javascript-test.ts</h4>
        <pre>import assert from &quot;node:assert&quot;;
import {readdirSync, statSync} from &quot;node:fs&quot;;
import {readFile, unlink, writeFile} from &quot;node:fs/promises&quot;;
import {basename, join, resolve} from &quot;node:path&quot;;
import {isNodeError} from &quot;../src/error.js&quot;;
import {transpileJavaScript} from &quot;../src/javascript.js&quot;;
import {renderDefineCell} from &quot;../src/render.js&quot;;

describe(&quot;transpileJavaScript(input)&quot;, () =&gt; {
  for (const name of readdirSync(&quot;./test/input&quot;)) {
    if (!name.endsWith(&quot;.js&quot;)) continue;
    const path = join(&quot;./test/input&quot;, name);
    if (!statSync(path).isFile()) continue;
    const only = name.startsWith(&quot;only.&quot;);
    const skip = name.startsWith(&quot;skip.&quot;);
    const outname = only || skip ? name.slice(5) : name;
    (only ? it.only : skip ? it.skip : it)(`test/input/${name}`, async () =&gt; {
      const outfile = resolve(&quot;./test/output&quot;, `${basename(outname, &quot;.js&quot;)}.js`);
      const diffile = resolve(&quot;./test/output&quot;, `${basename(outname, &quot;.js&quot;)}-changed.js`);
      const actual = renderDefineCell(
        await transpileJavaScript(await readFile(path, &quot;utf8&quot;), {id: &quot;0&quot;, root: &quot;test/input&quot;})
      );
      let expected;

      try {
        expected = await readFile(outfile, &quot;utf8&quot;);
      } catch (error) {
        if (isNodeError(error) &amp;&amp; error.code === &quot;ENOENT&quot; &amp;&amp; process.env.CI !== &quot;true&quot;) {
          console.warn(`! generating ${outfile}`);
          await writeFile(outfile, actual, &quot;utf8&quot;);
          return;
        } else {
          throw error;
        }
      }

      const equal = expected === actual;

      if (equal) {
        if (process.env.CI !== &quot;true&quot;) {
          try {
            await unlink(diffile);
            console.warn(`! deleted ${diffile}`);
          } catch (error) {
            if (!isNodeError(error) || error.code !== &quot;ENOENT&quot;) {
              throw error;
            }
          }
        }
      } else {
        console.warn(`! generating ${diffile}`);
        await writeFile(diffile, actual, &quot;utf8&quot;);
      }

      assert.ok(equal, `${name} must match snapshot`);
    });
  }
});
</pre><h3>input</h3><h5>yaml-frontmatter.md</h5>
        <pre>---
title: YAML
style:
  - one
  - two
---

# YAML frontmatter

This page has some YAML configuration.
</pre><h5>wellformed-block.md</h5>
        <pre># Well-formed block

&lt;div&gt;
  &lt;div&gt;content&lt;/div&gt;
&lt;/div&gt;
</pre><h5>var.js</h5>
        <pre>var foo = 1;
</pre><h5>try-catch.js</h5>
        <pre>try {
  let [x] = y;
  x++;
  display(x);
} catch (e) {
  display(e);
}
</pre><h5>top-level-yield.js</h5>
        <pre>yield 1;
</pre><h5>top-level-return.js</h5>
        <pre>return 1;
</pre><h5>this.js</h5>
        <pre>this
</pre><h5>tex-expression.md</h5>
        <pre># Hello, ${tex`\KaTeX`}

My favorite equation is ${tex`E = mc^2`}.
</pre><h5>template-expression.md</h5>
        <pre>${`}&apos;&quot;`}
</pre><h5>static-import.js</h5>
        <pre>import {foo} from &quot;./bar.js&quot;;

display(foo);
</pre><h5>single-quote-expression.md</h5>
        <pre>${&apos;}&quot;&apos;}
</pre><h5>semicolons.js</h5>
        <pre>;;
</pre><h5>semicolon.js</h5>
        <pre>;
</pre><h5>script-expression.md</h5>
        <pre># Script expression

&lt;script type=&quot;module&quot;&gt;

const subject = &quot;world&quot;;
const message = `Hello, ${subject}!`;

&lt;/script&gt;
</pre><h5>reserved-local.js</h5>
        <pre>const Array = false;
</pre><h5>reserved-function.js</h5>
        <pre>function Array() {}
</pre><h5>optional-chaining.js</h5>
        <pre>const dogName = adventurer.dog?.name;
</pre><h5>object-literal.js</h5>
        <pre>{a: 1}
</pre><h5>nullish-coalescing.js</h5>
        <pre>const foo = null ?? &quot;default string&quot;;
</pre><h5>markdown-in-html.md</h5>
        <pre># Markdown in HTML

&lt;div&gt;
  # Hello
&lt;/div&gt;
</pre><h5>malformed-block.md</h5>
        <pre># Malformed block

&lt;div&gt;

  &lt;div&gt;content&lt;/div&gt;

&lt;/div&gt;
</pre><h5>logical-assignment.js</h5>
        <pre>let a = null;
let b = false;
a ||= b;
</pre><h5>local-this.js</h5>
        <pre>const this = 42;
</pre><h5>local-fetch.md</h5>
        <pre># Local fetch

```js
fetch(&quot;./local-fetch.md&quot;)
```
</pre><h5>local-const.js</h5>
        <pre>{
  const x = 1;
}
</pre><h5>local-arguments.js</h5>
        <pre>const arguments = false;
</pre><h5>lets.js</h5>
        <pre>let x = 1, y = 2;
</pre><h5>let.js</h5>
        <pre>let x = 1;
</pre><h5>let-increment.js</h5>
        <pre>let x = 0;
++x;
x++;
</pre><h5>let-assign.js</h5>
        <pre>let x;
x = 1;
x = 2;
</pre><h5>legal-arguments.js</h5>
        <pre>function foo() { return arguments.length; }
</pre><h5>input.js</h5>
        <pre>const name = view(Inputs.text({label: &quot;Name&quot;}));
</pre><h5>inline-expression.md</h5>
        <pre>&lt;span&gt;${1 + 2}&lt;/span&gt;
</pre><h5>identifier.js</h5>
        <pre>foo
</pre><h5>hello-world.md</h5>
        <pre># Hello, world!

This is a test.
</pre><h5>heading-expression.md</h5>
        <pre># ${1 + 2}
</pre><h5>generator.js</h5>
        <pre>const x = (function*() {
  for (let i = 0; i &lt; 10; ++i) {
    yield i;
  }
})();
</pre><h5>generator-function.js</h5>
        <pre>function* foo() {
  yield 42;
}
</pre><h5>functions.js</h5>
        <pre>function add(a, b) {
  return a + b;
}

function subtract(a, b) {
  return a - b;
}
</pre><h5>function.js</h5>
        <pre>function add(a, b) {
  return a + b;
}
</pre><h5>for-await-of.js</h5>
        <pre>const values = [];
for await (const value of foo()) values.push(value);
</pre><h5>fenced-code.md</h5>
        <pre># Fenced code

```js show
function add(a, b) {
  return a + b;
}
```
</pre><h5>external-assignment.js</h5>
        <pre>x = 1;
</pre><h5>expression.js</h5>
        <pre>1 + 2
</pre><h5>expression-trailing-comment.js</h5>
        <pre>42 // Hello, comment.</pre><h5>expression-statement.js</h5>
        <pre>1 + 2;
</pre><h5>expression-leading-comment.js</h5>
        <pre>// Hello, comment.
42</pre><h5>expression-extra.js</h5>
        <pre>foo bar
</pre><h5>escaped-expression.md</h5>
        <pre>$\{1 + 2}
</pre><h5>empty.js</h5>
        <pre></pre><h5>embedded-expression.md</h5>
        <pre># Embedded expression

One plus two is ${1 + 2}.
</pre><h5>dynamic-import.js</h5>
        <pre>const foo = await import(&quot;./bar.js&quot;);
</pre><h5>double-quote-expression.md</h5>
        <pre>${&quot;}&apos;&quot;}
</pre><h5>dollar-expression.md</h5>
        <pre>$${1 + 2}
</pre><h5>default-initializer.js</h5>
        <pre>function fun(foo = x) {}
</pre><h5>databaseclient.md</h5>
        <pre>```js
const db = DatabaseClient(&quot;dwh-local-proxy&quot;);
```
</pre><h5>consts.js</h5>
        <pre>const x = 1, y = 2;
</pre><h5>const.js</h5>
        <pre>const x = 1;
</pre><h5>computed-property-name.js</h5>
        <pre>const x = ({[field]: value}) =&gt; value;
</pre><h5>comment.js</h5>
        <pre>// Hello, comment.
</pre><h5>comma-expression.js</h5>
        <pre>1, 2</pre><h5>comma-comment.js</h5>
        <pre>foo, // Oops, invalid syntax.
</pre><h5>classes.js</h5>
        <pre>class Foo {}
class Bar {}
</pre><h5>class.js</h5>
        <pre>class Foo {}
</pre><h5>block.js</h5>
        <pre>{
  display(42);
}
</pre><h5>block-trailing-comment.js</h5>
        <pre>{
  display(42);
}
// Hello, comment.</pre><h5>block-leading-comment.js</h5>
        <pre>// Hello, comment.
{
  display(42);
}</pre><h5>block-expression.md</h5>
        <pre>&lt;div&gt;${1 + 2}&lt;/div&gt;
</pre><h5>bigint.js</h5>
        <pre>foo + 42n
</pre><h5>bigint-zero.js</h5>
        <pre>0n
</pre><h5>await.js</h5>
        <pre>await promise
</pre><h5>async-template-literal.js</h5>
        <pre>md`${await promise}`
</pre><h5>async-function.js</h5>
        <pre>async function addAsync(a, b) {
  return (await a) + (await b);
}
</pre><h5>async-class.js</h5>
        <pre>class Foo {
  async addAsync(a, b) {
    return (await a) + (await b);
  }
}
</pre><h5>async-arrow-function.js</h5>
        <pre>const addAsync = async (a, b) =&gt; (await a) + (await b);
</pre><h5>anonymous-function.js</h5>
        <pre>function() { return 42; }
</pre><h5>anonymous-class.js</h5>
        <pre>class {}
</pre><h4>hash-test.ts</h4>
        <pre>import {computeHash} from &quot;../src/hash.js&quot;;
import assert from &quot;node:assert&quot;;

describe(&quot;computeHash(content)&quot;, () =&gt; {
  it(&quot;returns the expected result&quot;, () =&gt; {
    assert.deepStrictEqual(computeHash(&quot;&quot;), &quot;e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855&quot;);
    assert.deepStrictEqual(computeHash(&quot;hello&quot;), &quot;2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824&quot;);
  });
});
</pre><h2>src</h2><h4>sourcemap.js</h4>
        <pre>import {lineBreakG} from &quot;acorn&quot;;

export class Sourcemap {
  constructor(input = &quot;&quot;) {
    this._input = input;
    this._edits = [];
  }
  _bisectLeft(index) {
    let lo = 0;
    let hi = this._edits.length;
    while (lo &lt; hi) {
      const mid = (lo + hi) &gt;&gt;&gt; 1;
      if (this._edits[mid].start &lt; index) lo = mid + 1;
      else hi = mid;
    }
    return lo;
  }
  _bisectRight(index) {
    let lo = 0;
    let hi = this._edits.length;
    while (lo &lt; hi) {
      const mid = (lo + hi) &gt;&gt;&gt; 1;
      if (this._edits[mid].start &gt; index) hi = mid;
      else lo = mid + 1;
    }
    return lo;
  }
  insertLeft(index, value) {
    this.replaceLeft(index, index, value);
  }
  insertRight(index, value) {
    this.replaceRight(index, index, value);
  }
  delete(start, end) {
    this.replaceRight(start, end, &quot;&quot;);
  }
  replaceLeft(start, end, value) {
    this._edits.splice(this._bisectLeft(start), 0, {start, end, value});
  }
  replaceRight(start, end, value) {
    this._edits.splice(this._bisectRight(start), 0, {start, end, value});
  }
  translate(position) {
    let index = 0;
    let ci = {line: 1, column: 0};
    let co = {line: 1, column: 0};
    for (const {start, end, value} of this._edits) {
      if (start &gt; index) {
        const l = positionLength(this._input, index, start);
        const ci2 = positionAdd(ci, l);
        const co2 = positionAdd(co, l);
        if (positionCompare(co2, position) &gt; 0) break;
        ci = ci2;
        co = co2;
      }
      const il = positionLength(this._input, start, end);
      const ol = positionLength(value);
      const ci2 = positionAdd(ci, il);
      const co2 = positionAdd(co, ol);
      if (positionCompare(co2, position) &gt; 0) return ci;
      ci = ci2;
      co = co2;
      index = end;
    }
    const l = positionSubtract(position, co);
    return positionAdd(ci, l);
  }
  toString() {
    let output = &quot;&quot;;
    let index = 0;
    for (const {start, end, value} of this._edits) {
      if (start &gt; index) output += this._input.slice(index, start);
      output += value;
      index = end;
    }
    output += this._input.slice(index);
    return output;
  }
}

function positionCompare(a, b) {
  return a.line - b.line || a.column - b.column;
}

function positionLength(input, start = 0, end = input.length) {
  let match,
    line = 0;
  lineBreakG.lastIndex = start;
  while ((match = lineBreakG.exec(input)) &amp;&amp; match.index &lt; end) {
    ++line;
    start = match.index + match[0].length;
  }
  return {line, column: end - start};
}

function positionSubtract(b, a) {
  return b.line === a.line ? {line: 0, column: b.column - a.column} : {line: b.line - a.line, column: b.column};
}

function positionAdd(p, l) {
  return l.line === 0 ? {line: p.line, column: p.column + l.column} : {line: p.line + l.line, column: l.column};
}
</pre><h4>resolver.ts</h4>
        <pre>import {homedir} from &quot;os&quot;;
import {join} from &quot;path&quot;;
import {createHmac} from &quot;node:crypto&quot;;
import {readFile} from &quot;node:fs/promises&quot;;
import type {CellPiece} from &quot;./markdown.js&quot;;

export type CellResolver = (cell: CellPiece) =&gt; CellPiece;

export interface ResolvedDatabaseReference {
  name: string;
  origin: string;
  token: string;
  type: string;
}

interface DatabaseProxyItem {
  secret: string;
}

type DatabaseProxyConfig = Record&lt;string, DatabaseProxyItem&gt;;

interface ObservableConfig {
  &quot;database-proxy&quot;: DatabaseProxyConfig;
}

interface DatabaseConfig {
  host: string;
  name: string;
  origin?: string;
  port: number;
  secret: string;
  ssl: &quot;disabled&quot; | &quot;enabled&quot;;
  type: string;
  url: string;
}

const configFile = join(homedir(), &quot;.observablehq&quot;);
const key = `database-proxy`;

export async function readDatabaseProxyConfig(): Promise&lt;DatabaseProxyConfig | null&gt; {
  let observableConfig;
  try {
    observableConfig = JSON.parse(await readFile(configFile, &quot;utf-8&quot;)) as ObservableConfig | null;
  } catch (error) {
    // Ignore missing config file
  }
  return observableConfig &amp;&amp; observableConfig[key];
}

function readDatabaseConfig(config: DatabaseProxyConfig | null, name): DatabaseConfig {
  if (!config) throw new Error(`Missing database configuration file &quot;${configFile}&quot;`);
  if (!name) throw new Error(`No database name specified`);
  const raw = (config &amp;&amp; config[name]) as DatabaseConfig | null;
  if (!raw) throw new Error(`No configuration found for &quot;${name}&quot;`);
  return {
    ...decodeSecret(raw.secret),
    url: raw.url
  } as DatabaseConfig;
}

function decodeSecret(secret: string): Record&lt;string, string&gt; {
  return JSON.parse(Buffer.from(secret, &quot;base64&quot;).toString(&quot;utf8&quot;));
}

function encodeToken(payload: {name: string}, secret): string {
  const data = JSON.stringify(payload);
  const hmac = createHmac(&quot;sha256&quot;, Buffer.from(secret, &quot;hex&quot;)).update(data).digest();
  return `${Buffer.from(data).toString(&quot;base64&quot;) + &quot;.&quot; + Buffer.from(hmac).toString(&quot;base64&quot;)}`;
}

export async function makeCLIResolver(): Promise&lt;CellResolver&gt; {
  const config = await readDatabaseProxyConfig();
  return (cell: CellPiece): CellPiece =&gt; {
    if (&quot;databases&quot; in cell &amp;&amp; cell.databases !== undefined) {
      cell = {
        ...cell,
        databases: cell.databases.map((ref) =&gt; {
          const db = readDatabaseConfig(config, ref.name);
          if (db) {
            const url = new URL(&quot;http://localhost&quot;);
            url.protocol = db.ssl !== &quot;disabled&quot; ? &quot;https:&quot; : &quot;http:&quot;;
            url.host = db.host;
            url.port = String(db.port);
            url.toString();
            return {
              ...ref,
              token: encodeToken(ref, db.secret),
              type: db.type,
              url: url.toString()
            };
          }
          throw new Error(`Unable to resolve database &quot;${ref.name}&quot;`);
        })
      };
    }
    return cell;
  };
}
</pre><h4>render.ts</h4>
        <pre>import {computeHash} from &quot;./hash.js&quot;;
import {type FileReference, type ImportReference} from &quot;./javascript.js&quot;;
import type {CellPiece} from &quot;./markdown.js&quot;;
import {parseMarkdown, type ParseResult} from &quot;./markdown.js&quot;;

export interface Render {
  html: string;
  files: FileReference[];
  imports: ImportReference[];
}

export interface RenderOptions {
  root: string;
  path?: string;
  pages?: {path: string; name: string}[];
  resolver: (cell: CellPiece) =&gt; CellPiece;
}

export function renderPreview(source: string, options: RenderOptions): Render {
  const parseResult = parseMarkdown(source, options.root);
  return {
    html: render(parseResult, {...options, preview: true, hash: computeHash(source)}),
    files: parseResult.files,
    imports: parseResult.imports
  };
}

export function renderServerless(source: string, options: RenderOptions): Render {
  const parseResult = parseMarkdown(source, options.root);
  return {
    html: render(parseResult, options),
    files: parseResult.files,
    imports: parseResult.imports
  };
}

export function renderDefineCell(cell) {
  const {id, inline, inputs, outputs, files, body, databases} = cell;
  return `define({${Object.entries({id, inline, inputs, outputs, files, databases})
    .filter((arg) =&gt; arg[1] !== undefined)
    .map((arg) =&gt; `${arg[0]}: ${JSON.stringify(arg[1])}`)
    .join(&quot;, &quot;)}, body: ${body}});\n`;
}

type RenderInternalOptions =
  | {preview?: false; hash?: never} // serverless
  | {preview: true; hash: string}; // preview

function render(
  parseResult: ParseResult,
  {path, pages, preview, hash, resolver}: RenderOptions &amp; RenderInternalOptions
): string {
  const showSidebar = pages &amp;&amp; pages.length &gt; 1;
  const imports = getImportMap(parseResult);
  return `&lt;!DOCTYPE html&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;
${
  parseResult.title ? `&lt;title&gt;${escapeData(parseResult.title)}&lt;/title&gt;\n` : &quot;&quot;
}&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://fonts.googleapis.com/css2?family=Source+Serif+Pro:ital,wght@0,400;0,600;0,700;1,400;1,600;1,700&amp;display=swap&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/_observablehq/style.css&quot;&gt;
&lt;script type=&quot;importmap&quot;&gt;
${JSON.stringify({imports: Object.fromEntries(Array.from(imports, ([name, href]) =&gt; [name, href]))}, null, 2)}
&lt;/script&gt;
${Array.from(imports.values())
  .concat(parseResult.imports.filter(({name}) =&gt; name.startsWith(&quot;./&quot;)).map(({name}) =&gt; `/_file/${name.slice(2)}`))
  .map((href) =&gt; `&lt;link rel=&quot;modulepreload&quot; href=&quot;${href}&quot;&gt;`)
  .join(&quot;\n&quot;)}
${
  parseResult.cells.some((cell) =&gt; cell.databases?.length)
    ? `&lt;link rel=&quot;modulepreload&quot; href=&quot;/_observablehq/database.js&quot;&gt;`
    : &quot;&quot;
}
&lt;script type=&quot;module&quot;&gt;

import {${preview ? &quot;open, &quot; : &quot;&quot;}define} from &quot;/_observablehq/client.js&quot;;

${preview ? `open({hash: ${JSON.stringify(hash)}});\n` : &quot;&quot;}${parseResult.cells
    .map(resolver)
    .map(renderDefineCell)
    .join(&quot;&quot;)}
&lt;/script&gt;${
    parseResult.data
      ? `
&lt;script type=&quot;application/json&quot;&gt;
${JSON.stringify(parseResult.data)}
&lt;/script&gt;`
      : &quot;&quot;
  }
${
  showSidebar
    ? `&lt;input id=&quot;observablehq-sidebar-toggle&quot; type=&quot;checkbox&quot;&gt;
&lt;nav id=&quot;observablehq-sidebar&quot;&gt;
  &lt;ol&gt;${pages
    ?.map(
      (p) =&gt; `
    &lt;li class=&quot;observablehq-link${p.path === path ? &quot; observablehq-link-active&quot; : &quot;&quot;}&quot;&gt;&lt;a href=&quot;${escapeDoubleQuoted(
      p.path.replace(/\/index$/, &quot;/&quot;)
    )}&quot;&gt;${escapeData(p.name)}&lt;/a&gt;&lt;/li&gt;`
    )
    .join(&quot;&quot;)}
  &lt;/ol&gt;
&lt;/nav&gt;
&lt;script&gt;{
  const toggle = document.querySelector(&quot;#observablehq-sidebar-toggle&quot;);
  const initialState = localStorage.getItem(&quot;observablehq-sidebar&quot;);
  if (initialState) toggle.checked = initialState === &quot;true&quot;;
  else toggle.indeterminate = true;
}&lt;/script&gt;
`
    : &quot;&quot;
}&lt;div id=&quot;observablehq-center&quot;&gt;
&lt;main id=&quot;observablehq-main&quot; class=&quot;observablehq&quot;&gt;
${parseResult.html}&lt;/main&gt;
&lt;footer id=&quot;observablehq-footer&quot;&gt; ${new Date().getUTCFullYear()} Observable, Inc.&lt;/footer&gt;
&lt;/div&gt;
`;
}

function getImportMap(parseResult: ParseResult): Map&lt;string, string&gt; {
  const map = new Map([[&quot;npm:@observablehq/runtime&quot;, &quot;/_observablehq/runtime.js&quot;]]);
  const npm = new Set&lt;string&gt;();
  for (const {name} of parseResult.imports) if (name.startsWith(&quot;npm:&quot;)) npm.add(name);
  const inputs = new Set(parseResult.cells.flatMap((cell) =&gt; cell.inputs ?? []));
  if (inputs.has(&quot;d3&quot;) || inputs.has(&quot;Plot&quot;)) npm.add(&quot;npm:d3&quot;);
  if (inputs.has(&quot;Plot&quot;)) npm.add(&quot;npm:@observablehq/plot&quot;);
  if (inputs.has(&quot;htl&quot;) || inputs.has(&quot;html&quot;) || inputs.has(&quot;svg&quot;) || inputs.has(&quot;Inputs&quot;)) npm.add(&quot;npm:htl&quot;);
  if (inputs.has(&quot;Inputs&quot;)) npm.add(&quot;npm:@observablehq/inputs&quot;);
  for (const name of npm) map.set(name, `https://cdn.jsdelivr.net/npm/${name.slice(4)}/+esm`);
  return map;
}

// TODO Adopt Hypertext Literal?
function escapeDoubleQuoted(value): string {
  return `${value}`.replace(/[&quot;&amp;]/g, entity);
}

// TODO Adopt Hypertext Literal?
function escapeData(value: string): string {
  return `${value}`.replace(/[&lt;&amp;]/g, entity);
}

function entity(character) {
  return `&amp;#${character.charCodeAt(0).toString()};`;
}
</pre><h4>preview.ts</h4>
        <pre>import type {WatchListener} from &quot;node:fs&quot;;
import {watch, type FSWatcher} from &quot;node:fs&quot;;
import {access, constants, readFile, stat} from &quot;node:fs/promises&quot;;
import {createServer, type IncomingMessage, type RequestListener} from &quot;node:http&quot;;
import {basename, dirname, extname, join, normalize} from &quot;node:path&quot;;
import {fileURLToPath} from &quot;node:url&quot;;
import {parseArgs} from &quot;node:util&quot;;
import send from &quot;send&quot;;
import {WebSocketServer, type WebSocket} from &quot;ws&quot;;
import {HttpError, isHttpError, isNodeError} from &quot;./error.js&quot;;
import type {ParseResult} from &quot;./markdown.js&quot;;
import {diffMarkdown, readMarkdown} from &quot;./markdown.js&quot;;
import {readPages} from &quot;./navigation.js&quot;;
import {renderPreview} from &quot;./render.js&quot;;
import type {CellResolver} from &quot;./resolver.js&quot;;
import {makeCLIResolver} from &quot;./resolver.js&quot;;
import {findLoader, runCommand} from &quot;./dataloader.js&quot;;
import {getStats} from &quot;./files.js&quot;;

const publicRoot = join(dirname(fileURLToPath(import.meta.url)), &quot;..&quot;, &quot;public&quot;);
const cacheRoot = join(dirname(fileURLToPath(import.meta.url)), &quot;..&quot;, &quot;.observablehq&quot;, &quot;cache&quot;);

class Server {
  private _server: ReturnType&lt;typeof createServer&gt;;
  private _socketServer: WebSocketServer;
  readonly port: number;
  readonly hostname: string;
  readonly root: string;
  readonly cacheRoot: string;
  private _resolver: CellResolver | undefined;

  constructor({port, hostname, root, cacheRoot}: CommandContext) {
    this.port = port;
    this.hostname = hostname;
    this.root = root;
    this.cacheRoot = cacheRoot;
    this._server = createServer();
    this._server.on(&quot;request&quot;, this._handleRequest);
    this._socketServer = new WebSocketServer({server: this._server});
    this._socketServer.on(&quot;connection&quot;, this._handleConnection);
  }

  async start() {
    this._resolver = await makeCLIResolver();
    return new Promise&lt;void&gt;((resolve) =&gt; {
      this._server.listen(this.port, this.hostname, resolve);
    });
  }

  _handleRequest: RequestListener = async (req, res) =&gt; {
    console.log(req.method, req.url);
    const url = new URL(req.url!, &quot;http://localhost&quot;);
    let {pathname} = url;
    try {
      if (pathname === &quot;/_observablehq/runtime.js&quot;) {
        send(req, &quot;/@observablehq/runtime/dist/runtime.js&quot;, {root: &quot;./node_modules&quot;}).pipe(res);
      } else if (pathname.startsWith(&quot;/_observablehq/&quot;)) {
        send(req, pathname.slice(&quot;/_observablehq&quot;.length), {root: publicRoot}).pipe(res);
      } else if (pathname.startsWith(&quot;/_file/&quot;)) {
        const path = pathname.slice(&quot;/_file&quot;.length);
        const filepath = join(this.root, path);
        try {
          await access(filepath, constants.R_OK);
          send(req, pathname.slice(&quot;/_file&quot;.length), {root: this.root}).pipe(res);
        } catch (error) {
          if (isNodeError(error) &amp;&amp; error.code !== &quot;ENOENT&quot;) {
            throw error;
          }
        }

        // Look for a data loader for this file.
        const {path: loaderPath, stats: loaderStat} = await findLoader(this.root, path);
        if (loaderStat) {
          const cachePath = join(this.cacheRoot, filepath);
          const cacheStat = await getStats(cachePath);
          if (cacheStat &amp;&amp; cacheStat.mtimeMs &gt; loaderStat.mtimeMs) {
            send(req, filepath, {root: this.cacheRoot}).pipe(res);
            return;
          }
          if (!(loaderStat.mode &amp; constants.S_IXUSR)) {
            throw new HttpError(&quot;Data loader is not executable&quot;, 404);
          }
          await runCommand(loaderPath, cachePath);
          send(req, filepath, {root: this.cacheRoot}).pipe(res);
          return;
        }
        throw new HttpError(&quot;Not found&quot;, 404);
      } else {
        if (normalize(pathname).startsWith(&quot;..&quot;)) throw new Error(&quot;Invalid path: &quot; + pathname);
        let path = join(this.root, pathname);

        // If this path is for /index, redirect to the parent directory for a
        // tidy path. (This must be done before implicitly adding /index below!)
        if (basename(path, &quot;.html&quot;) === &quot;index&quot;) {
          res.writeHead(302, {Location: dirname(pathname) + url.search});
          res.end();
          return;
        }

        // If this path resolves to a directory, then add an implicit /index to
        // the end of the path, assuming that the corresponding index.md exists.
        try {
          if ((await stat(path)).isDirectory() &amp;&amp; (await stat(join(path, &quot;index&quot;) + &quot;.md&quot;)).isFile()) {
            await access(join(path, &quot;index&quot;) + &quot;.md&quot;, constants.R_OK);
            pathname = join(pathname, &quot;index&quot;);
            path = join(path, &quot;index&quot;);
          }
        } catch (error) {
          if (!isNodeError(error) || error.code !== &quot;ENOENT&quot;) throw error; // internal error
        }

        // If this path ends with .html, then redirect to drop the .html. TODO:
        // Check for the existence of the .md file first.
        if (extname(path) === &quot;.html&quot;) {
          res.writeHead(302, {Location: join(dirname(pathname), basename(pathname, &quot;.html&quot;)) + url.search});
          res.end();
          return;
        }

        // Otherwise, serve the corresponding Markdown file, if it exists.
        // Anything else should 404; static files should be matched above.
        try {
          const pages = await readPages(this.root); // TODO cache? watcher?
          res.end(
            (
              await renderPreview(await readFile(path + &quot;.md&quot;, &quot;utf-8&quot;), {
                root: this.root,
                path: pathname,
                pages,
                resolver: this._resolver!
              })
            ).html
          );
        } catch (error) {
          if (!isNodeError(error) || error.code !== &quot;ENOENT&quot;) throw error; // internal error
          throw new HttpError(&quot;Not found&quot;, 404);
        }
      }
    } catch (error) {
      console.error(error);
      res.statusCode = isHttpError(error) ? error.statusCode : 500;
      res.setHeader(&quot;Content-Type&quot;, &quot;text/plain; charset=utf-8&quot;);
      res.end(error instanceof Error ? error.message : &quot;Oops, an error occurred&quot;);
    }
  };

  _handleConnection = (socket: WebSocket, req: IncomingMessage) =&gt; {
    if (req.url === &quot;/_observablehq&quot;) {
      handleWatch(socket, {root: this.root, resolver: this._resolver!});
    } else {
      socket.close();
    }
  };
}

class FileWatchers {
  watchers: FSWatcher[] = [];

  constructor(
    readonly root: string,
    readonly files: {name: string}[],
    readonly cb: (name: string) =&gt; void
  ) {}

  async watchAll() {
    const fileset = [...new Set(this.files.map(({name}) =&gt; name))];
    for (const name of fileset) {
      const watchPath = await FileWatchers.getWatchPath(this.root, name);
      let prevState = await getStats(watchPath);
      this.watchers.push(
        watch(watchPath, async () =&gt; {
          const newState = await getStats(watchPath);
          // Ignore if the file was truncated or not modified.
          if (prevState?.mtimeMs === newState?.mtimeMs || newState?.size === 0) return;
          prevState = newState;
          this.cb(name);
        })
      );
    }
  }

  static async getWatchPath(root: string, name: string) {
    const path = join(root, name);
    const stats = await getStats(path);
    if (stats?.isFile()) return path;
    const {path: loaderPath, stats: loaderStat} = await findLoader(root, name);
    return loaderStat?.isFile() ? loaderPath : path;
  }

  close() {
    this.watchers.forEach((w) =&gt; w.close());
    this.watchers = [];
  }
}

function resolveDiffs(diff: ReturnType&lt;typeof diffMarkdown&gt;, resolver: CellResolver): ReturnType&lt;typeof diffMarkdown&gt; {
  for (const item of diff) {
    if (item.type === &quot;add&quot;) {
      for (const addItem of item.items) {
        if (addItem.type === &quot;cell&quot; &amp;&amp; &quot;databases&quot; in addItem) {
          Object.assign(addItem, resolver(addItem));
        }
      }
    }
  }
  return diff;
}

function handleWatch(socket: WebSocket, options: {root: string; resolver: CellResolver}) {
  const {root, resolver} = options;
  let markdownWatcher: FSWatcher | null = null;
  let attachmentWatcher: FileWatchers | null = null;
  console.log(&quot;socket open&quot;);

  function refreshAttachment(parseResult: ParseResult) {
    return (name: string) =&gt;
      send({
        type: &quot;refresh&quot;,
        cellIds: parseResult.cells.filter((cell) =&gt; cell.files?.some((f) =&gt; f.name === name)).map((cell) =&gt; cell.id)
      });
  }

  async function refreshMarkdown(path: string): Promise&lt;WatchListener&lt;string&gt;&gt; {
    let current = await readMarkdown(path, root);
    attachmentWatcher = new FileWatchers(root, current.parse.files, refreshAttachment(current.parse));
    await attachmentWatcher.watchAll();
    return async function watcher(event) {
      switch (event) {
        case &quot;rename&quot;: {
          markdownWatcher?.close();
          try {
            markdownWatcher = watch(path, watcher);
          } catch (error) {
            if (isNodeError(error) &amp;&amp; error.code === &quot;ENOENT&quot;) {
              console.error(`file no longer exists: ${path}`);
              socket.terminate();
              return;
            }
            throw error;
          }
          setTimeout(() =&gt; watcher(&quot;change&quot;), 150); // delay to avoid a possibly-empty file
          break;
        }
        case &quot;change&quot;: {
          const updated = await readMarkdown(path, root);
          if (current.hash === updated.hash) break;
          const diff = resolveDiffs(diffMarkdown(current, updated), resolver);
          send({type: &quot;update&quot;, diff, previousHash: current.hash, updatedHash: updated.hash});
          attachmentWatcher?.close();
          attachmentWatcher = new FileWatchers(root, updated.parse.files, refreshAttachment(updated.parse));
          current = updated;
          break;
        }
        default:
          throw new Error(&quot;Unrecognized event: &quot; + event);
      }
    };
  }

  socket.on(&quot;message&quot;, async (data) =&gt; {
    try {
      const message = JSON.parse(String(data));
      console.log(&quot;&quot;, message);
      switch (message.type) {
        case &quot;hello&quot;: {
          if (markdownWatcher || attachmentWatcher) throw new Error(&quot;already watching&quot;);
          let {path} = message;
          if (normalize(path).startsWith(&quot;..&quot;)) throw new Error(&quot;Invalid path: &quot; + path);
          if (path.endsWith(&quot;/&quot;)) path += &quot;index&quot;;
          path = join(root, normalize(path) + &quot;.md&quot;);
          markdownWatcher = watch(path, await refreshMarkdown(path));
          break;
        }
      }
    } catch (error) {
      console.error(&quot;Protocol error&quot;, error);
      socket.terminate();
    }
  });

  socket.on(&quot;error&quot;, (error) =&gt; {
    console.error(&quot;error&quot;, error);
  });

  socket.on(&quot;close&quot;, () =&gt; {
    if (attachmentWatcher) {
      attachmentWatcher.close();
      attachmentWatcher = null;
    }
    if (markdownWatcher) {
      markdownWatcher.close();
      markdownWatcher = null;
    }
    console.log(&quot;socket close&quot;);
  });

  function send(message) {
    console.log(&quot;&quot;, message);
    socket.send(JSON.stringify(message));
  }
}

const USAGE = `Usage: observable preview [--root dir] [--hostname host] [--port port]`;

interface CommandContext {
  root: string;
  hostname: string;
  port: number;
  cacheRoot: string;
}

function makeCommandContext(): CommandContext {
  const {values} = parseArgs({
    options: {
      root: {
        type: &quot;string&quot;,
        short: &quot;r&quot;,
        default: &quot;docs&quot;
      },
      hostname: {
        type: &quot;string&quot;,
        short: &quot;h&quot;
      },
      port: {
        type: &quot;string&quot;,
        short: &quot;p&quot;
      }
    }
  });
  if (!values.root) {
    console.error(USAGE);
    process.exit(1);
  }
  return {
    root: normalize(values.root).replace(/\/$/, &quot;&quot;),
    hostname: values.hostname ?? process.env.HOSTNAME ?? &quot;127.0.0.1&quot;,
    port: values.port ? +values.port : process.env.PORT ? +process.env.PORT : 3000,
    cacheRoot
  };
}

// TODO A --root option should indicate the current working directory within
// which to find Markdown files, for both --serve and --build. The serving paths
// and generated file paths should be relative to the root. For example, if the
// root is ./docs, then / should serve ./docs/index.md, and that same Markdown
// file should be generated as ./dist/index.html when using --output ./dist.

await (async function () {
  const context = makeCommandContext();
  const server = new Server(context);
  await server.start();
  console.log(`Server running at http://${server.hostname}:${server.port}/`);
})();
</pre><h4>navigation.ts</h4>
        <pre>import {readFile} from &quot;node:fs/promises&quot;;
import {basename, dirname, extname, join} from &quot;node:path&quot;;
import {isNodeError} from &quot;./error.js&quot;;
import {visitFiles} from &quot;./files.js&quot;;
import {parseMarkdown, type ParseResult} from &quot;./markdown.js&quot;;
import {type RenderOptions} from &quot;./render.js&quot;;

// TODO Global configuration file? Watcher?
export async function readPages(root: string): Promise&lt;NonNullable&lt;RenderOptions[&quot;pages&quot;]&gt;&gt; {
  const pages: RenderOptions[&quot;pages&quot;] = [];
  for await (const file of visitFiles(root)) {
    if (extname(file) !== &quot;.md&quot;) continue;
    let parsed: ParseResult;
    try {
      parsed = parseMarkdown(await readFile(join(root, file), &quot;utf-8&quot;), root);
    } catch (error) {
      if (!isNodeError(error) || error.code !== &quot;ENOENT&quot;) throw error; // internal error
      continue;
    }
    const name = basename(file, &quot;.md&quot;);
    const page = {path: `/${join(dirname(file), name)}`, name: parsed.title ?? &quot;Untitled&quot;};
    if (name === &quot;index&quot;) pages.unshift(page);
    else pages.push(page);
  }
  return pages;
}
</pre><h4>markdown.ts</h4>
        <pre>import {getPatch, type Patch, type PatchItem} from &quot;fast-array-diff&quot;;
import equal from &quot;fast-deep-equal&quot;;
import matter from &quot;gray-matter&quot;;
import hljs from &quot;highlight.js&quot;;
import {parseHTML} from &quot;linkedom&quot;;
import MarkdownIt from &quot;markdown-it&quot;;
import MarkdownItAnchor from &quot;markdown-it-anchor&quot;;
import {type RuleCore} from &quot;markdown-it/lib/parser_core.js&quot;;
import {type RuleInline} from &quot;markdown-it/lib/parser_inline.js&quot;;
import {type default as Renderer, type RenderRule} from &quot;markdown-it/lib/renderer.js&quot;;
import mime from &quot;mime&quot;;
import {readFile} from &quot;node:fs/promises&quot;;
import {pathFromRoot} from &quot;./files.js&quot;;
import {computeHash} from &quot;./hash.js&quot;;
import {transpileJavaScript, type FileReference, type ImportReference, type Transpile} from &quot;./javascript.js&quot;;

export interface ReadMarkdownResult {
  contents: string;
  parse: ParseResult;
  hash: string;
}

export interface HtmlPiece {
  type: &quot;html&quot;;
  id: string;
  html: string;
  cellIds?: string[];
}

export interface CellPiece extends Transpile {
  type: &quot;cell&quot;;
}

export type ParsePiece = HtmlPiece | CellPiece;

export interface ParseResult {
  title: string | null;
  html: string;
  data: {[key: string]: any} | null;
  files: FileReference[];
  imports: ImportReference[];
  pieces: HtmlPiece[];
  cells: CellPiece[];
}

interface RenderPiece {
  html: string;
  code: Transpile[];
}

interface ParseContext {
  pieces: RenderPiece[];
  files: {name: string; mimeType: string | null}[];
  imports: ImportReference[];
  startLine: number;
  currentLine: number;
}

const TEXT_NODE = 3; // Node.TEXT_NODE

// Returns true if the given document contains exactly one top-level element,
// ignoring any surrounding whitespace text nodes.
function isSingleElement(document: Document): boolean {
  let {firstChild: first, lastChild: last} = document;
  while (first?.nodeType === TEXT_NODE &amp;&amp; !first?.textContent?.trim()) first = first.nextSibling;
  while (last?.nodeType === TEXT_NODE &amp;&amp; !last?.textContent?.trim()) last = last.previousSibling;
  return first !== null &amp;&amp; first === last &amp;&amp; first.nodeType !== TEXT_NODE;
}

function uniqueCodeId(context: ParseContext, content: string): string {
  const hash = computeHash(content).slice(0, 8);
  let id = hash;
  let count = 1;
  while (context.pieces.some((piece) =&gt; piece.code.some((code) =&gt; code.id === id))) {
    id = `${hash}-${count++}`;
  }
  return id;
}

function makeFenceRenderer(root: string, baseRenderer: RenderRule): RenderRule {
  return (tokens, idx, options, context: ParseContext, self) =&gt; {
    const token = tokens[idx];
    const [language, option] = token.info.split(&quot; &quot;);
    let result = &quot;&quot;;
    let count = 0;
    if (language === &quot;js&quot; &amp;&amp; option !== &quot;no-run&quot;) {
      const id = uniqueCodeId(context, token.content);
      const transpile = transpileJavaScript(token.content, {
        id,
        root,
        sourceLine: context.startLine + context.currentLine
      });
      extendPiece(context, {code: [transpile]});
      if (transpile.files) context.files.push(...transpile.files);
      if (transpile.imports) context.imports.push(...transpile.imports);
      result += `&lt;div id=&quot;cell-${id}&quot; class=&quot;observablehq observablehq--block&quot;&gt;&lt;/div&gt;\n`;
      count++;
    }
    if (language !== &quot;js&quot; || option === &quot;show&quot; || option === &quot;no-run&quot;) {
      result += baseRenderer(tokens, idx, options, context, self);
      count++;
    }
    // Tokens should always be rendered as a single block element.
    if (count &gt; 1) result = &quot;&lt;div&gt;&quot; + result + &quot;&lt;/div&gt;&quot;;
    return result;
  };
}

const CODE_DOLLAR = 36;
const CODE_BRACEL = 123;
const CODE_BRACER = 125;
const CODE_BACKSLASH = 92;
const CODE_QUOTE = 34;
const CODE_SINGLE_QUOTE = 39;
const CODE_BACKTICK = 96;

function parsePlaceholder(content: string, replacer: (i: number, j: number) =&gt; void) {
  let afterDollar = false;
  for (let j = 0, n = content.length; j &lt; n; ++j) {
    const cj = content.charCodeAt(j);
    if (cj === CODE_BACKSLASH) {
      ++j; // skip next character
      continue;
    }
    if (cj === CODE_DOLLAR) {
      afterDollar = true;
      continue;
    }
    if (afterDollar) {
      if (cj === CODE_BRACEL) {
        let quote = 0; // TODO detect comments, too
        let braces = 0;
        let k = j + 1;
        inner: for (; k &lt; n; ++k) {
          const ck = content.charCodeAt(k);
          if (ck === CODE_BACKSLASH) {
            ++k;
            continue;
          }
          if (quote) {
            if (ck === quote) quote = 0;
            continue;
          }
          switch (ck) {
            case CODE_QUOTE:
            case CODE_SINGLE_QUOTE:
            case CODE_BACKTICK:
              quote = ck;
              break;
            case CODE_BRACEL:
              ++braces;
              break;
            case CODE_BRACER:
              if (--braces &lt; 0) {
                replacer(j - 1, k + 1);
                break inner;
              }
              break;
          }
        }
        j = k;
      }
      afterDollar = false;
    }
  }
}

function transformPlaceholderBlock(token) {
  const input = token.content;
  if (/^\s*&lt;script(\s|&gt;)/.test(input)) return [token]; // ignore &lt;script&gt; elements
  const output: any[] = [];
  let i = 0;
  parsePlaceholder(input, (j, k) =&gt; {
    output.push({...token, level: i &gt; 0 ? token.level + 1 : token.level, content: input.slice(i, j)});
    output.push({type: &quot;placeholder&quot;, level: token.level + 1, content: input.slice(j + 2, k - 1)});
    i = k;
  });
  if (i === 0) return [token];
  else if (i &lt; input.length) output.push({...token, content: input.slice(i), nesting: -1});
  return output;
}

const transformPlaceholderInline: RuleInline = (state, silent) =&gt; {
  if (silent || state.pos + 2 &gt; state.posMax) return false;
  const marker1 = state.src.charCodeAt(state.pos);
  const marker2 = state.src.charCodeAt(state.pos + 1);
  if (!(marker1 === CODE_DOLLAR &amp;&amp; marker2 === CODE_BRACEL)) return false;
  let quote = 0;
  let braces = 0;
  for (let pos = state.pos + 2; pos &lt; state.posMax; ++pos) {
    const code = state.src.charCodeAt(pos);
    if (code === CODE_BACKSLASH) {
      ++pos; // skip next character
      continue;
    }
    if (quote) {
      if (code === quote) quote = 0;
      continue;
    }
    switch (code) {
      case CODE_QUOTE:
      case CODE_SINGLE_QUOTE:
      case CODE_BACKTICK:
        quote = code;
        break;
      case CODE_BRACEL:
        ++braces;
        break;
      case CODE_BRACER:
        if (--braces &lt; 0) {
          const token = state.push(&quot;placeholder&quot;, &quot;&quot;, 0);
          token.content = state.src.slice(state.pos + 2, pos);
          state.pos = pos + 1;
          return true;
        }
        break;
    }
  }
  return false;
};

const transformPlaceholderCore: RuleCore = (state) =&gt; {
  const input = state.tokens;
  const output: any[] = [];
  for (const token of input) {
    switch (token.type) {
      case &quot;html_block&quot;:
        output.push(...transformPlaceholderBlock(token));
        break;
      default:
        output.push(token);
        break;
    }
  }
  state.tokens = output;
};

function makePlaceholderRenderer(root: string): RenderRule {
  return (tokens, idx, options, context: ParseContext) =&gt; {
    const id = uniqueCodeId(context, tokens[idx].content);
    const token = tokens[idx];
    const transpile = transpileJavaScript(token.content, {
      id,
      root,
      inline: true,
      sourceLine: context.startLine + context.currentLine
    });
    extendPiece(context, {code: [transpile]});
    if (transpile.files) context.files.push(...transpile.files);
    return `&lt;span id=&quot;cell-${id}&quot;&gt;&lt;/span&gt;`;
  };
}

function makeSoftbreakRenderer(baseRenderer: RenderRule): RenderRule {
  return (tokens, idx, options, context: ParseContext, self) =&gt; {
    context.currentLine++;
    return baseRenderer(tokens, idx, options, context, self);
  };
}

function extendPiece(context: ParseContext, extend: Partial&lt;RenderPiece&gt;) {
  if (context.pieces.length === 0) context.pieces.push({html: &quot;&quot;, code: []});
  const last = context.pieces[context.pieces.length - 1];
  context.pieces[context.pieces.length - 1] = {
    html: last.html + (extend.html ?? &quot;&quot;),
    code: [...last.code, ...(extend.code ? extend.code : [])]
  };
}

function renderIntoPieces(renderer: Renderer, root: string): Renderer[&quot;render&quot;] {
  return (tokens, options, context: ParseContext) =&gt; {
    const rules = renderer.rules;
    for (let i = 0, len = tokens.length; i &lt; len; i++) {
      const type = tokens[i].type;
      if (tokens[i].map) context.currentLine = tokens[i].map![0];
      let html = &quot;&quot;;
      if (type === &quot;inline&quot;) {
        html = renderer.renderInline(tokens[i].children!, options, context);
      } else if (typeof rules[type] !== &quot;undefined&quot;) {
        if (tokens[i].level === 0 &amp;&amp; tokens[i].nesting !== -1) context.pieces.push({html: &quot;&quot;, code: []});
        html = rules[type]!(tokens, i, options, context, renderer);
      } else {
        if (tokens[i].level === 0 &amp;&amp; tokens[i].nesting !== -1) context.pieces.push({html: &quot;&quot;, code: []});
        html = renderer.renderToken(tokens, i, options);
      }
      extendPiece(context, {html});
    }
    let result = &quot;&quot;;
    for (const piece of context.pieces) {
      result += piece.html = normalizePieceHtml(piece.html, root, context);
    }
    return result;
  };
}

// In addition to extracting references to files (such as from linked
// stylesheets), this ensures that the HTML for each piece generates exactly one
// top-level element. This is necessary for incremental update, and ensures that
// our parsing of the Markdown is consistent with the resulting HTML structure.
function normalizePieceHtml(html: string, root: string, context: ParseContext): string {
  const {document} = parseHTML(html);
  for (const element of document.querySelectorAll(&quot;link[href]&quot;) as any as Iterable&lt;Element&gt;) {
    const href = pathFromRoot(element.getAttribute(&quot;href&quot;), root);
    if (href) {
      context.files.push({name: href, mimeType: mime.getType(href)});
      element.setAttribute(&quot;href&quot;, `/_file/${href}`);
    }
  }
  return isSingleElement(document) ? String(document) : `&lt;span&gt;${document}&lt;/span&gt;`;
}

function toParsePieces(pieces: RenderPiece[]): HtmlPiece[] {
  return pieces.map((piece) =&gt; ({
    type: &quot;html&quot;,
    id: &quot;&quot;,
    cellIds: piece.code.map((code) =&gt; `${code.id}`),
    html: piece.html
  }));
}

function toParseCells(pieces: RenderPiece[]): CellPiece[] {
  const cellPieces: CellPiece[] = [];
  pieces.forEach((piece) =&gt;
    piece.code.forEach((code) =&gt;
      cellPieces.push({
        type: &quot;cell&quot;,
        ...code
      })
    )
  );
  return cellPieces;
}

export function parseMarkdown(source: string, root: string): ParseResult {
  const parts = matter(source);
  // TODO: We need to know what line in the source the markdown starts on and pass that
  // as startLine in the parse context below.
  const md = MarkdownIt({
    html: true,
    highlight(str, language) {
      if (language &amp;&amp; hljs.getLanguage(language)) {
        try {
          return hljs.highlight(str, {language}).value;
        } catch (error) {
          console.error(error);
        }
      }
      return &quot;&quot;; // defaults to escapeHtml(str)
    }
  });
  md.use(MarkdownItAnchor, {permalink: MarkdownItAnchor.permalink.headerLink({class: &quot;observablehq-header-anchor&quot;})});
  md.inline.ruler.push(&quot;placeholder&quot;, transformPlaceholderInline);
  md.core.ruler.before(&quot;linkify&quot;, &quot;placeholder&quot;, transformPlaceholderCore);
  md.renderer.rules.placeholder = makePlaceholderRenderer(root);
  md.renderer.rules.fence = makeFenceRenderer(root, md.renderer.rules.fence!);
  md.renderer.rules.softbreak = makeSoftbreakRenderer(md.renderer.rules.softbreak!);
  md.renderer.render = renderIntoPieces(md.renderer, root);
  const context: ParseContext = {files: [], imports: [], pieces: [], startLine: 0, currentLine: 0};
  const tokens = md.parse(parts.content, context);
  const html = md.renderer.render(tokens, md.options, context); // Note: mutates context.pieces, context.files!
  return {
    html,
    data: isEmpty(parts.data) ? null : parts.data,
    title: parts.data?.title ?? findTitle(tokens) ?? null,
    files: context.files,
    imports: context.imports,
    pieces: toParsePieces(context.pieces),
    cells: toParseCells(context.pieces)
  };
}

// TODO Use gray-matters parts.isEmpty, but only when its accurate.
function isEmpty(object) {
  for (const key in object) return false;
  return true;
}

// TODO Make this smarter.
function findTitle(tokens: ReturnType&lt;MarkdownIt[&quot;parse&quot;]&gt;): string | undefined {
  for (const [i, token] of tokens.entries()) {
    if (token.type === &quot;heading_open&quot; &amp;&amp; token.tag === &quot;h1&quot;) {
      const next = tokens[i + 1];
      if (next?.type === &quot;inline&quot;) {
        const text = next.children
          ?.filter((t) =&gt; t.type === &quot;text&quot;)
          .map((t) =&gt; t.content)
          .join(&quot;&quot;);
        if (text) {
          return text;
        }
      }
    }
  }
}

function diffReducer(patch: PatchItem&lt;ParsePiece&gt;) {
  // Remove body from remove updates, we just need the ids.
  if (patch.type === &quot;remove&quot;) {
    return {
      ...patch,
      items: patch.items.map((item) =&gt; ({
        type: item.type,
        id: item.id,
        ...(&quot;cellIds&quot; in item ? {cellIds: item.cellIds} : null)
      }))
    };
  }
  return patch;
}

// Cells are unordered
function getCellsPatch(prevCells: CellPiece[], nextCells: CellPiece[]): Patch&lt;ParsePiece&gt; {
  return prevCells
    .filter((prev) =&gt; !nextCells.some((next) =&gt; equal(prev, next)))
    .map(
      (cell): PatchItem&lt;ParsePiece&gt; =&gt; ({
        type: &quot;remove&quot;,
        oldPos: prevCells.indexOf(cell),
        newPos: -1,
        items: [cell]
      })
    )
    .concat(
      nextCells
        .filter((next) =&gt; !prevCells.some((prev) =&gt; equal(next, prev)))
        .map(
          (cell): PatchItem&lt;ParsePiece&gt; =&gt; ({
            type: &quot;add&quot;,
            oldPos: -1,
            newPos: nextCells.indexOf(cell),
            items: [cell]
          })
        )
    );
}

export function diffMarkdown({parse: prevParse}: ReadMarkdownResult, {parse: nextParse}: ReadMarkdownResult) {
  return getPatch&lt;ParsePiece&gt;(prevParse.pieces, nextParse.pieces, equal)
    .concat(getCellsPatch(prevParse.cells, nextParse.cells))
    .map(diffReducer);
}

export async function readMarkdown(path: string, root: string): Promise&lt;ReadMarkdownResult&gt; {
  const contents = await readFile(path, &quot;utf-8&quot;);
  return {contents, parse: parseMarkdown(contents, root), hash: computeHash(contents)};
}
</pre><h4>javascript.ts</h4>
        <pre>import {Parser, tokTypes, type Options} from &quot;acorn&quot;;
import mime from &quot;mime&quot;;
import {findAwaits} from &quot;./javascript/awaits.js&quot;;
import {findDeclarations} from &quot;./javascript/declarations.js&quot;;
import {findFeatures} from &quot;./javascript/features.js&quot;;
import {rewriteFetches} from &quot;./javascript/fetches.js&quot;;
import {defaultGlobals} from &quot;./javascript/globals.js&quot;;
import {findImports, rewriteImports} from &quot;./javascript/imports.js&quot;;
import {findReferences} from &quot;./javascript/references.js&quot;;
import {Sourcemap} from &quot;./sourcemap.js&quot;;

export interface DatabaseReference {
  name: string;
}

export interface FileReference {
  name: string;
  mimeType: string | null;
}

export interface ImportReference {
  name: string;
}

export interface Transpile {
  id: string;
  inputs?: string[];
  outputs?: string[];
  inline?: boolean;
  body: string;
  databases?: DatabaseReference[];
  files?: FileReference[];
  imports?: ImportReference[];
}

export interface ParseOptions {
  id: string;
  root: string;
  inline?: boolean;
  sourceLine?: number;
  globals?: Set&lt;string&gt;;
}

export function transpileJavaScript(input: string, options: ParseOptions): Transpile {
  const {id} = options;
  try {
    const node = parseJavaScript(input, options);
    const databases = node.features.filter((f) =&gt; f.type === &quot;DatabaseClient&quot;).map((f) =&gt; ({name: f.name}));
    const files = node.features
      .filter((f) =&gt; f.type === &quot;FileAttachment&quot;)
      .map((f) =&gt; ({name: f.name, mimeType: mime.getType(f.name)}));
    const inputs = Array.from(new Set&lt;string&gt;(node.references.map((r) =&gt; r.name)));
    const output = new Sourcemap(input);
    trim(output, input);
    if (node.expression &amp;&amp; !inputs.includes(&quot;display&quot;) &amp;&amp; !inputs.includes(&quot;view&quot;)) {
      output.insertLeft(0, &quot;display((\n&quot;);
      output.insertRight(input.length, &quot;\n))&quot;);
      inputs.push(&quot;display&quot;);
    }
    rewriteImports(output, node);
    rewriteFetches(output, node);
    return {
      id,
      ...(inputs.length ? {inputs} : null),
      ...(options.inline ? {inline: true} : null),
      ...(node.declarations?.length ? {outputs: node.declarations.map(({name}) =&gt; name)} : null),
      ...(databases.length ? {databases} : null),
      ...(files.length ? {files} : null),
      body: `${node.async ? &quot;async &quot; : &quot;&quot;}(${inputs}) =&gt; {
${String(output)}${node.declarations?.length ? `\nreturn {${node.declarations.map(({name}) =&gt; name)}};` : &quot;&quot;}
}`,
      ...(node.imports.length ? {imports: node.imports} : null)
    };
  } catch (error) {
    if (!(error instanceof SyntaxError)) throw error;
    let message = error.message;
    const match = /^(.+)\s\((\d+):(\d+)\)$/.exec(message);
    if (match) {
      const line = +match[2] + (options?.sourceLine ?? 0);
      const column = +match[3] + 1;
      message = `${match[1]} at line ${line}, column ${column}`;
    } else if (options?.sourceLine) {
      message = `${message} at line ${options.sourceLine + 1}`;
    }
    // TODO: Consider showing a code snippet along with the error. Also, consider
    // whether we want to show the file name here.
    console.error(`${error.name}: ${message}`);
    return {
      id: `${id}`,
      body: `() =&gt; { throw new SyntaxError(${JSON.stringify(error.message)}); }`
    };
  }
}

function trim(output: Sourcemap, input: string): void {
  if (input.startsWith(&quot;\n&quot;)) output.delete(0, 1); // TODO better trim
  if (input.endsWith(&quot;\n&quot;)) output.delete(input.length - 1, input.length); // TODO better trim
}

export const parseOptions: Options = {ecmaVersion: 13, sourceType: &quot;module&quot;};

export function parseJavaScript(input: string, options: ParseOptions) {
  const {globals = defaultGlobals, inline = false, root} = options;
  // First attempt to parse as an expression; if this fails, parse as a program.
  let expression = maybeParseExpression(input, parseOptions);
  if (expression?.type === &quot;ClassExpression&quot; &amp;&amp; expression.id) expression = null; // treat named class as program
  if (expression?.type === &quot;FunctionExpression&quot; &amp;&amp; expression.id) expression = null; // treat named function as program
  if (!expression &amp;&amp; inline) throw new SyntaxError(&quot;invalid expression&quot;);
  const body = expression ?? (Parser.parse(input, parseOptions) as any);
  const references = findReferences(body, globals, input);
  const declarations = expression ? null : findDeclarations(body, globals, input);
  const features = findFeatures(body, references, input);
  const imports = findImports(body, root);
  return {
    body,
    declarations,
    references,
    features,
    imports,
    expression: !!expression,
    async: findAwaits(body).length &gt; 0
  };
}

// Parses a single expression; like parseExpressionAt, but returns null if
// additional input follows the expression.
function maybeParseExpression(input, options) {
  const parser = new Parser(options, input, 0);
  parser.nextToken();
  try {
    const node = (parser as any).parseExpression();
    return parser.type === tokTypes.eof ? node : null;
  } catch {
    return null;
  }
}
</pre><h3>javascript</h3><h5>syntaxError.js</h5>
        <pre>import {getLineInfo} from &quot;acorn&quot;;

export function syntaxError(message, node, input) {
  const loc = getLineInfo(input, node.start);
  const error = new SyntaxError(message + ` (${loc.line}:${loc.column})`);
  error.pos = node.start;
  error.loc = loc;
  return error;
}
</pre><h5>references.js</h5>
        <pre>import {ancestor, simple} from &quot;acorn-walk&quot;;
import {syntaxError} from &quot;./syntaxError.js&quot;;

// Based on https://github.com/ForbesLindesay/acorn-globals
// Copyright (c) 2014 Forbes Lindesay
// https://github.com/ForbesLindesay/acorn-globals/blob/master/LICENSE

function isScope(node) {
  return (
    node.type === &quot;FunctionExpression&quot; ||
    node.type === &quot;FunctionDeclaration&quot; ||
    node.type === &quot;ArrowFunctionExpression&quot; ||
    node.type === &quot;Program&quot;
  );
}

function isBlockScope(node) {
  return (
    node.type === &quot;BlockStatement&quot; ||
    node.type === &quot;ForInStatement&quot; ||
    node.type === &quot;ForOfStatement&quot; ||
    node.type === &quot;ForStatement&quot; ||
    isScope(node)
  );
}

export function findReferences(node, globals, input) {
  const locals = new Map();
  const globalSet = new Set(globals);
  const references = [];

  function hasLocal(node, name) {
    const l = locals.get(node);
    return l ? l.has(name) : false;
  }

  function declareLocal(node, id) {
    const l = locals.get(node);
    if (l) l.add(id.name);
    else locals.set(node, new Set([id.name]));
  }

  function declareClass(node) {
    if (node.id) declareLocal(node, node.id);
  }

  function declareFunction(node) {
    node.params.forEach((param) =&gt; declarePattern(param, node));
    if (node.id) declareLocal(node, node.id);
    if (node.type !== &quot;ArrowFunctionExpression&quot;) declareLocal(node, {name: &quot;arguments&quot;});
  }

  function declareCatchClause(node) {
    if (node.param) declarePattern(node.param, node);
  }

  function declarePattern(node, parent) {
    switch (node.type) {
      case &quot;Identifier&quot;:
        declareLocal(parent, node);
        break;
      case &quot;ObjectPattern&quot;:
        node.properties.forEach((node) =&gt; declarePattern(node, parent));
        break;
      case &quot;ArrayPattern&quot;:
        node.elements.forEach((node) =&gt; node &amp;&amp; declarePattern(node, parent));
        break;
      case &quot;Property&quot;:
        declarePattern(node.value, parent);
        break;
      case &quot;RestElement&quot;:
        declarePattern(node.argument, parent);
        break;
      case &quot;AssignmentPattern&quot;:
        declarePattern(node.left, parent);
        break;
      default:
        throw new Error(&quot;Unrecognized pattern type: &quot; + node.type);
    }
  }

  function declareImportSpecifier(node, parent) {
    switch (node.type) {
      case &quot;ImportSpecifier&quot;:
      case &quot;ImportNamespaceSpecifier&quot;:
      case &quot;ImportDefaultSpecifier&quot;:
        declareLocal(parent, node.local);
        break;
      default:
        throw new Error(&quot;Unrecognized import type: &quot; + node.type);
    }
  }

  ancestor(node, {
    VariableDeclaration(node, parents) {
      let parent = null;
      for (let i = parents.length - 1; i &gt;= 0 &amp;&amp; parent === null; --i) {
        if (node.kind === &quot;var&quot; ? isScope(parents[i]) : isBlockScope(parents[i])) {
          parent = parents[i];
        }
      }
      node.declarations.forEach((declaration) =&gt; declarePattern(declaration.id, parent));
    },
    FunctionDeclaration(node, parents) {
      let parent = null;
      for (let i = parents.length - 2; i &gt;= 0 &amp;&amp; parent === null; --i) {
        if (isScope(parents[i])) {
          parent = parents[i];
        }
      }
      declareLocal(parent, node.id);
      declareFunction(node);
    },
    Function: declareFunction,
    ClassDeclaration(node, parents) {
      let parent = null;
      for (let i = parents.length - 2; i &gt;= 0 &amp;&amp; parent === null; i--) {
        if (isScope(parents[i])) {
          parent = parents[i];
        }
      }
      declareLocal(parent, node.id);
    },
    Class: declareClass,
    CatchClause: declareCatchClause,
    ImportDeclaration(node, [root]) {
      node.specifiers.forEach((specifier) =&gt; declareImportSpecifier(specifier, root));
    }
  });

  function identifier(node, parents) {
    let name = node.name;
    if (name === &quot;undefined&quot;) return;
    for (let i = parents.length - 2; i &gt;= 0; --i) {
      if (hasLocal(parents[i], name)) {
        node.declarationDepth = i; // TODO link to declaration?
        return;
      }
    }
    if (!globalSet.has(name)) {
      references.push(node);
    }
  }

  ancestor(node, {
    VariablePattern: identifier,
    Identifier: identifier
  });

  function checkConst(node) {
    switch (node?.type) {
      case &quot;Identifier&quot;:
      case &quot;VariablePattern&quot;: {
        if (references.includes(node)) throw syntaxError(`Assignment to external variable &apos;${node.name}&apos;`, node, input);
        if (globals.has(node.name)) throw syntaxError(`Assignment to global &apos;${node.name}&apos;`, node, input);
        break;
      }
      case &quot;ArrayPattern&quot;: {
        for (const element of node.elements) checkConst(element);
        break;
      }
      case &quot;ObjectPattern&quot;: {
        for (const property of node.properties) checkConst(property);
        break;
      }
      case &quot;Property&quot;: {
        checkConst(node.value);
        break;
      }
      case &quot;RestElement&quot;: {
        checkConst(node.argument);
        break;
      }
    }
  }

  simple(node, {
    AssignmentExpression(node) {
      checkConst(node.left);
    },
    AssignmentPattern(node) {
      checkConst(node.left);
    },
    UpdateExpression(node) {
      checkConst(node.argument);
    },
    ForOfStatement(node) {
      checkConst(node.left);
    },
    ForInStatement(node) {
      checkConst(node.left);
    }
  });

  return references;
}
</pre><h5>imports.ts</h5>
        <pre>import {Parser} from &quot;acorn&quot;;
import {simple} from &quot;acorn-walk&quot;;
import {readFileSync} from &quot;node:fs&quot;;
import {dirname, join, relative, resolve} from &quot;node:path&quot;;
import {parseOptions} from &quot;../javascript.js&quot;;
import {getStringLiteralValue, isStringLiteral} from &quot;./features.js&quot;;

export function findImports(body, root) {
  const imports: {name: string}[] = [];
  const paths = new Set&lt;string&gt;();

  simple(body, {
    ImportDeclaration: findImport,
    ImportExpression: findImport,
    ExportAllDeclaration: findImport,
    ExportNamedDeclaration: findImport
  });

  function findImport(node) {
    if (isStringLiteral(node.source)) {
      const value = getStringLiteralValue(node.source);
      if (value.startsWith(&quot;./&quot;)) findLocalImports(join(root, value));
      imports.push({name: value});
    }
  }

  // If this is an import of a local ES module, recursively parse the module to
  // find transitive imports.
  function findLocalImports(path) {
    if (paths.has(path)) return;
    paths.add(path);
    try {
      const input = readFileSync(path, &quot;utf-8&quot;);
      const program = Parser.parse(input, parseOptions);
      simple(program, {
        ImportDeclaration: findLocalImport,
        ImportExpression: findLocalImport,
        ExportAllDeclaration: findLocalImport,
        ExportNamedDeclaration: findLocalImport
      });
    } catch {
      // ignore missing files and syntax errors
    }
    function findLocalImport(node) {
      if (isStringLiteral(node.source)) {
        const value = getStringLiteralValue(node.source);
        if (value.startsWith(&quot;./&quot;)) {
          const subpath = resolve(dirname(path), value);
          findLocalImports(subpath);
          imports.push({name: `./${relative(root, subpath)}`});
        } else {
          imports.push({name: value});
        }
      }
    }
  }

  return imports;
}

// TODO parallelize multiple static imports
// TODO need to know the local path of the importing notebook; this assumes its in the root
export function rewriteImports(output, root) {
  simple(root.body, {
    ImportExpression(node: any) {
      if (isStringLiteral(node.source)) {
        const value = getStringLiteralValue(node.source);
        if (value.startsWith(&quot;./&quot;)) {
          output.replaceLeft(node.source.start + 1, node.source.start + 3, &quot;/_file/&quot;);
        }
      }
    },
    ImportDeclaration(node: any) {
      if (isStringLiteral(node.source)) {
        const value = getStringLiteralValue(node.source);
        root.async = true;
        output.replaceLeft(
          node.start,
          node.end,
          `const ${
            node.specifiers.some(isNotNamespaceSpecifier)
              ? `{${node.specifiers.filter(isNotNamespaceSpecifier).map(rewriteImportSpecifier).join(&quot;, &quot;)}}`
              : node.specifiers.some(isNamespaceSpecifier)
              ? node.specifiers.find(isNamespaceSpecifier).local.name
              : &quot;{}&quot;
          } = await import(${value.startsWith(&quot;./&quot;) ? JSON.stringify(&quot;/_file/&quot; + value.slice(2)) : node.source.raw});`
        );
      }
    }
  });
}

function rewriteImportSpecifier(node) {
  return node.type === &quot;ImportDefaultSpecifier&quot;
    ? `default: ${node.local.name}`
    : node.imported.name === node.local.name
    ? node.local.name
    : `${node.imported.name}: ${node.local.name}`;
}

function isNamespaceSpecifier(node) {
  return node.type === &quot;ImportNamespaceSpecifier&quot;;
}

function isNotNamespaceSpecifier(node) {
  return node.type !== &quot;ImportNamespaceSpecifier&quot;;
}
</pre><h5>globals.js</h5>
        <pre>export const defaultGlobals = new Set([
  &quot;Array&quot;,
  &quot;ArrayBuffer&quot;,
  &quot;atob&quot;,
  &quot;AudioContext&quot;,
  &quot;Blob&quot;,
  &quot;Boolean&quot;,
  &quot;BigInt&quot;,
  &quot;btoa&quot;,
  &quot;clearInterval&quot;,
  &quot;clearTimeout&quot;,
  &quot;console&quot;,
  &quot;crypto&quot;,
  &quot;CustomEvent&quot;,
  &quot;DataView&quot;,
  &quot;Date&quot;,
  &quot;decodeURI&quot;,
  &quot;decodeURIComponent&quot;,
  &quot;devicePixelRatio&quot;,
  &quot;document&quot;,
  &quot;encodeURI&quot;,
  &quot;encodeURIComponent&quot;,
  &quot;Error&quot;,
  &quot;escape&quot;,
  &quot;eval&quot;,
  &quot;fetch&quot;,
  &quot;File&quot;,
  &quot;FileList&quot;,
  &quot;FileReader&quot;,
  &quot;Float32Array&quot;,
  &quot;Float64Array&quot;,
  &quot;Function&quot;,
  &quot;Headers&quot;,
  &quot;Image&quot;,
  &quot;ImageData&quot;,
  &quot;Infinity&quot;,
  &quot;Int16Array&quot;,
  &quot;Int32Array&quot;,
  &quot;Int8Array&quot;,
  &quot;Intl&quot;,
  &quot;isFinite&quot;,
  &quot;isNaN&quot;,
  &quot;JSON&quot;,
  &quot;Map&quot;,
  &quot;Math&quot;,
  &quot;NaN&quot;,
  &quot;Number&quot;,
  &quot;navigator&quot;,
  &quot;Object&quot;,
  &quot;parseFloat&quot;,
  &quot;parseInt&quot;,
  &quot;performance&quot;,
  &quot;Path2D&quot;,
  &quot;Promise&quot;,
  &quot;Proxy&quot;,
  &quot;RangeError&quot;,
  &quot;ReferenceError&quot;,
  &quot;Reflect&quot;,
  &quot;RegExp&quot;,
  &quot;cancelAnimationFrame&quot;,
  &quot;requestAnimationFrame&quot;,
  &quot;Set&quot;,
  &quot;setInterval&quot;,
  &quot;setTimeout&quot;,
  &quot;String&quot;,
  &quot;Symbol&quot;,
  &quot;SyntaxError&quot;,
  &quot;TextDecoder&quot;,
  &quot;TextEncoder&quot;,
  &quot;this&quot;,
  &quot;TypeError&quot;,
  &quot;Uint16Array&quot;,
  &quot;Uint32Array&quot;,
  &quot;Uint8Array&quot;,
  &quot;Uint8ClampedArray&quot;,
  &quot;undefined&quot;,
  &quot;unescape&quot;,
  &quot;URIError&quot;,
  &quot;URL&quot;,
  &quot;WeakMap&quot;,
  &quot;WeakSet&quot;,
  &quot;WebSocket&quot;,
  &quot;Worker&quot;,
  &quot;window&quot;
]);
</pre><h5>fetches.js</h5>
        <pre>import {simple} from &quot;acorn-walk&quot;;
import {isLocalFetch} from &quot;./features.js&quot;;

export function rewriteFetches(output, root) {
  simple(root.body, {
    CallExpression(node) {
      if (isLocalFetch(node, root.references)) {
        output.insertLeft(node.arguments[0].start + 3, &quot;_file/&quot;);
      }
    }
  });
}
</pre><h5>features.js</h5>
        <pre>import {simple} from &quot;acorn-walk&quot;;
import {syntaxError} from &quot;./syntaxError.js&quot;;

export function findFeatures(node, references, input) {
  const features = [];

  simple(node, {
    CallExpression(node) {
      const {
        callee,
        arguments: args,
        arguments: [arg]
      } = node;

      // Promote fetches with static literals to file attachment references.
      if (isLocalFetch(node, references)) {
        features.push({type: &quot;FileAttachment&quot;, name: getStringLiteralValue(arg)});
        return;
      }

      // Ignore function calls that are not references to the feature. For
      // example, if theres a local variable called Secret, that will mask the
      // built-in Secret and wont be considered a feature.
      if (
        callee.type !== &quot;Identifier&quot; ||
        (callee.name !== &quot;Secret&quot; &amp;&amp; callee.name !== &quot;FileAttachment&quot; &amp;&amp; callee.name !== &quot;DatabaseClient&quot;) ||
        !references.includes(callee)
      ) {
        return;
      }

      // Forbid dynamic calls.
      if (args.length !== 1 || !isStringLiteral(arg)) {
        throw syntaxError(`${callee.name} requires a single literal string argument`, node, input);
      }

      features.push({type: callee.name, name: getStringLiteralValue(arg)});
    },
    // Promote dynamic imports with static literals to file attachment references.
    ImportExpression: findImport,
    ImportDeclaration: findImport
  });

  function findImport(node) {
    if (isStringLiteral(node.source)) {
      const value = getStringLiteralValue(node.source);
      if (value.startsWith(&quot;./&quot;)) {
        features.push({type: &quot;FileAttachment&quot;, name: value});
      }
    }
  }

  return features;
}

export function isLocalFetch(node, references) {
  if (node.type !== &quot;CallExpression&quot;) return false;
  const {
    callee,
    arguments: [arg]
  } = node;
  return (
    callee.type === &quot;Identifier&quot; &amp;&amp;
    callee.name === &quot;fetch&quot; &amp;&amp;
    !references.includes(callee) &amp;&amp;
    arg &amp;&amp;
    isStringLiteral(arg) &amp;&amp;
    getStringLiteralValue(arg).startsWith(&quot;./&quot;)
  );
}

export function isStringLiteral(node) {
  return (
    (node.type === &quot;Literal&quot; &amp;&amp; /^[&apos;&quot;]/.test(node.raw)) ||
    (node.type === &quot;TemplateLiteral&quot; &amp;&amp; node.expressions.length === 0)
  );
}

export function getStringLiteralValue(node) {
  return node.type === &quot;Literal&quot; ? node.value : node.quasis[0].value.cooked;
}
</pre><h5>declarations.js</h5>
        <pre>import {syntaxError} from &quot;./syntaxError.js&quot;;

export function findDeclarations(node, globals, input) {
  if (node.type !== &quot;Program&quot;) throw new Error(`unexpected type: ${node.type}`);

  const declarations = [];

  function declareLocal(node) {
    if (globals.has(node.name) || node.name === &quot;arguments&quot;) {
      throw syntaxError(`Global &apos;${node.name}&apos; cannot be redefined`, node, input);
    }
    declarations.push(node);
  }

  function declarePattern(node) {
    switch (node.type) {
      case &quot;Identifier&quot;:
        declareLocal(node);
        break;
      case &quot;ObjectPattern&quot;:
        node.properties.forEach((node) =&gt; declarePattern(node));
        break;
      case &quot;ArrayPattern&quot;:
        node.elements.forEach((node) =&gt; node &amp;&amp; declarePattern(node));
        break;
      case &quot;Property&quot;:
        declarePattern(node.value);
        break;
      case &quot;RestElement&quot;:
        declarePattern(node.argument);
        break;
      case &quot;AssignmentPattern&quot;:
        declarePattern(node.left);
        break;
      default:
        throw new Error(&quot;Unrecognized pattern type: &quot; + node.type);
    }
  }

  function declareImportSpecifier(node) {
    switch (node.type) {
      case &quot;ImportSpecifier&quot;:
      case &quot;ImportNamespaceSpecifier&quot;:
      case &quot;ImportDefaultSpecifier&quot;:
        declareLocal(node.local);
        break;
      default:
        throw new Error(&quot;Unrecognized import type: &quot; + node.type);
    }
  }

  for (const child of node.body) {
    switch (child.type) {
      case &quot;VariableDeclaration&quot;:
        child.declarations.forEach((declaration) =&gt; declarePattern(declaration.id));
        break;
      case &quot;ClassDeclaration&quot;:
      case &quot;FunctionDeclaration&quot;:
        declareLocal(child.id);
        break;
      case &quot;ImportDeclaration&quot;:
        child.specifiers.forEach((specifier) =&gt; declareImportSpecifier(specifier));
        break;
      case &quot;Class&quot;:
      case &quot;Function&quot;:
        throw new Error(`unexpected type: ${child.type}`);
    }
  }

  return declarations;
}
</pre><h5>awaits.js</h5>
        <pre>import {recursive} from &quot;acorn-walk&quot;;

export function findAwaits(node) {
  const nodes = [];

  recursive(node, null, {
    Function() {}, // ignore anything inside a function
    ForOfStatement(node) {
      if (node.await) nodes.push(node);
    },
    AwaitExpression(node) {
      nodes.push(node);
    }
  });

  return nodes;
}
</pre><h4>hash.ts</h4>
        <pre>import {createHash} from &quot;node:crypto&quot;;

export function computeHash(source: string): string {
  return createHash(&quot;sha256&quot;).update(source).digest(&quot;hex&quot;);
}
</pre><h4>files.ts</h4>
        <pre>import type {Stats} from &quot;node:fs&quot;;
import {accessSync, constants, statSync} from &quot;node:fs&quot;;
import {mkdir, readdir, stat} from &quot;node:fs/promises&quot;;
import {dirname, extname, join, normalize, relative} from &quot;node:path&quot;;
import {isNodeError} from &quot;./error.js&quot;;

// A file is local if it exists in the root folder or a subfolder.
export function isLocalFile(ref: string | null, root: string): boolean {
  return (
    typeof ref === &quot;string&quot; &amp;&amp;
    !/^(\w+:)\/\//.test(ref) &amp;&amp;
    !normalize(ref).startsWith(&quot;../&quot;) &amp;&amp;
    canReadSync(join(root, ref))
  );
}

export function pathFromRoot(ref: string | null, root: string): string | null {
  return isLocalFile(ref, root) ? join(root, ref!) : null;
}

function canReadSync(path: string): boolean {
  try {
    accessSync(path, constants.R_OK);
    return statSync(path).isFile();
  } catch (error) {
    if (isNodeError(error) &amp;&amp; error.code === &quot;ENOENT&quot;) return false;
    throw error;
  }
}

export async function* visitMarkdownFiles(root: string): AsyncGenerator&lt;string&gt; {
  for await (const file of visitFiles(root)) {
    if (extname(file) !== &quot;.md&quot;) continue;
    yield file;
  }
}

export async function* visitFiles(root: string): AsyncGenerator&lt;string&gt; {
  const visited = new Set&lt;number&gt;();
  const queue: string[] = [(root = normalize(root))];
  for (const path of queue) {
    const status = await stat(path);
    if (status.isDirectory()) {
      if (visited.has(status.ino)) throw new Error(`Circular directory: ${path}`);
      visited.add(status.ino);
      for (const entry of await readdir(path)) {
        queue.push(join(path, entry));
      }
    } else {
      yield relative(root, path);
    }
  }
}

export async function getStats(path: string): Promise&lt;Stats | undefined&gt; {
  try {
    return await stat(path);
  } catch (error) {
    if (!isNodeError(error) || error.code !== &quot;ENOENT&quot;) throw error;
  }
  return;
}

export async function prepareOutput(outputPath: string): Promise&lt;void&gt; {
  const outputDir = dirname(outputPath);
  if (outputDir === &quot;.&quot;) return;
  await mkdir(outputDir, {recursive: true});
}
</pre><h4>error.ts</h4>
        <pre>export class HttpError extends Error {
  public readonly statusCode: number;

  constructor(message: string, statusCode: number, cause?: any) {
    super(message ?? `HTTP status ${statusCode}`, cause);
    this.statusCode = statusCode;
    Error.captureStackTrace(this, HttpError);
  }
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function isNodeError(error: any): error is NodeJS.ErrnoException {
  return error instanceof Error &amp;&amp; &quot;errno&quot; in error;
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function isHttpError(error: any): error is HttpError {
  return error instanceof Error &amp;&amp; &quot;statusCode&quot; in error;
}
</pre><h4>dataloader.ts</h4>
        <pre>import {open} from &quot;node:fs/promises&quot;;
import {spawn} from &quot;node:child_process&quot;;
import {join} from &quot;node:path&quot;;
import {getStats, prepareOutput} from &quot;./files.js&quot;;
import {renameSync, unlinkSync} from &quot;node:fs&quot;;

const runningCommands = new Map&lt;string, Promise&lt;void&gt;&gt;();

export async function runCommand(commandPath: string, outputPath: string) {
  if (runningCommands.has(commandPath)) return runningCommands.get(commandPath);
  const command = new Promise&lt;void&gt;((resolve, reject) =&gt; {
    const outputTempPath = outputPath + &quot;.tmp&quot;;
    prepareOutput(outputTempPath).then(() =&gt;
      open(outputTempPath, &quot;w&quot;).then((cacheFd) =&gt; {
        const cacheFileStream = cacheFd.createWriteStream({highWaterMark: 1024 * 1024});
        try {
          const subprocess = spawn(commandPath, [], {
            argv0: commandPath,
            //cwd: dirname(commandPath), // TODO: Need to change commandPath to be relative this?
            windowsHide: true,
            stdio: [&quot;ignore&quot;, &quot;pipe&quot;, &quot;inherit&quot;]
            // timeout: // time in ms
            // signal: // abort signal
          });
          subprocess.stdout.on(&quot;data&quot;, (data) =&gt; cacheFileStream.write(data));
          subprocess.on(&quot;error&quot;, (error) =&gt; console.error(`${commandPath}: ${error.message}`));
          subprocess.on(&quot;close&quot;, (code) =&gt; {
            cacheFd.close().then(() =&gt; {
              if (code === 0) {
                renameSync(outputTempPath, outputPath);
              } else {
                unlinkSync(outputTempPath);
              }
              resolve();
            }, reject);
          });
        } catch (error) {
          reject(error);
        } finally {
          runningCommands.delete(commandPath);
        }
      })
    );
  });
  runningCommands.set(commandPath, command);
  return command;
}

export async function findLoader(root: string, name: string) {
  // TODO: It may be more efficient use fs.readdir
  for (const ext of [&quot;.js&quot;, &quot;.ts&quot;, &quot;.sh&quot;]) {
    const path = join(root, name) + ext;
    const stats = await getStats(path);
    if (stats) return {path, stats};
  }
  return {};
}
</pre><h4>build.ts</h4>
        <pre>import {access, constants, copyFile, readFile, writeFile} from &quot;node:fs/promises&quot;;
import {basename, dirname, join, normalize, relative} from &quot;node:path&quot;;
import {cwd} from &quot;node:process&quot;;
import {fileURLToPath} from &quot;node:url&quot;;
import {parseArgs} from &quot;node:util&quot;;
import {getStats, prepareOutput, visitFiles, visitMarkdownFiles} from &quot;./files.js&quot;;
import {readPages} from &quot;./navigation.js&quot;;
import {renderServerless} from &quot;./render.js&quot;;
import {makeCLIResolver} from &quot;./resolver.js&quot;;
import {findLoader, runCommand} from &quot;./dataloader.js&quot;;

const EXTRA_FILES = new Map([[&quot;node_modules/@observablehq/runtime/dist/runtime.js&quot;, &quot;_observablehq/runtime.js&quot;]]);

async function build(context: CommandContext) {
  const {sourceRoot, outputRoot} = context;

  // Make sure all files are readable before starting to write output files.
  for await (const sourceFile of visitMarkdownFiles(sourceRoot)) {
    await access(join(sourceRoot, sourceFile), constants.R_OK);
  }

  // Render .md files, building a list of file attachments as we go.
  const pages = await readPages(sourceRoot);
  const files: string[] = [];
  const resolver = await makeCLIResolver();
  for await (const sourceFile of visitMarkdownFiles(sourceRoot)) {
    const sourcePath = join(sourceRoot, sourceFile);
    const outputPath = join(outputRoot, join(dirname(sourceFile), basename(sourceFile, &quot;.md&quot;) + &quot;.html&quot;));
    console.log(&quot;render&quot;, sourcePath, &quot;&quot;, outputPath);
    const path = `/${join(dirname(sourceFile), basename(sourceFile, &quot;.md&quot;))}`;
    const render = renderServerless(await readFile(sourcePath, &quot;utf-8&quot;), {
      root: sourceRoot,
      path,
      pages,
      resolver
    });
    files.push(...render.files.map((f) =&gt; join(sourceFile, &quot;..&quot;, f.name)));
    await prepareOutput(outputPath);
    await writeFile(outputPath, render.html);
  }

  // Copy over the public directory.
  const publicRoot = join(dirname(relative(cwd(), fileURLToPath(import.meta.url))), &quot;..&quot;, &quot;public&quot;);
  for await (const publicFile of visitFiles(publicRoot)) {
    const sourcePath = join(publicRoot, publicFile);
    const outputPath = join(outputRoot, &quot;_observablehq&quot;, publicFile);
    console.log(&quot;copy&quot;, sourcePath, &quot;&quot;, outputPath);
    await prepareOutput(outputPath);
    await copyFile(sourcePath, outputPath);
  }

  // Copy over the referenced files.
  for (const file of files) {
    const sourcePath = join(sourceRoot, file);
    const outputPath = join(outputRoot, &quot;_file&quot;, file);
    const stats = await getStats(sourcePath);
    if (!stats) {
      const {path} = await findLoader(&quot;&quot;, sourcePath);
      if (!path) {
        console.error(&quot;missing referenced file&quot;, sourcePath);
        continue;
      }
      console.log(&quot;generate&quot;, path, &quot;&quot;, outputPath);
      await runCommand(path, outputPath);
      continue;
    }
    console.log(&quot;copy&quot;, sourcePath, &quot;&quot;, outputPath);
    await prepareOutput(outputPath);
    await copyFile(sourcePath, outputPath);
  }

  // Copy over required distribution files from node_modules.
  // TODO: Note that this requires that the build command be run relative to the node_modules directory.
  for (const [sourcePath, targetFile] of EXTRA_FILES) {
    const outputPath = join(outputRoot, targetFile);
    console.log(&quot;copy&quot;, sourcePath, &quot;&quot;, outputPath);
    await prepareOutput(outputPath);
    await copyFile(sourcePath, outputPath);
  }
}

const USAGE = `Usage: observable build [--root dir] [--output dir]`;

interface CommandContext {
  sourceRoot: string;
  outputRoot: string;
}

function makeCommandContext(): CommandContext {
  const {values} = parseArgs({
    options: {
      root: {
        type: &quot;string&quot;,
        short: &quot;r&quot;,
        default: &quot;docs&quot;
      },
      output: {
        type: &quot;string&quot;,
        short: &quot;o&quot;,
        default: &quot;dist&quot;
      }
    }
  });
  if (!values.root || !values.output) {
    console.error(USAGE);
    process.exit(1);
  }
  return {
    sourceRoot: normalize(values.root).replace(/\/$/, &quot;&quot;),
    outputRoot: normalize(values.output).replace(/\/$/, &quot;&quot;)
  };
}

await (async function () {
  const context = makeCommandContext();
  await build(context);
  process.exit(0);
})();
</pre><h2>public</h2><h4>database.js</h4>
        <pre>export function makeDatabaseClient(resolveToken) {
  return function DatabaseClient(name) {
    if (new.target !== undefined) throw new TypeError(&quot;DatabaseClient is not a constructor&quot;);
    return resolveToken((name += &quot;&quot;)).then((token) =&gt; new DatabaseClientImpl(name, token));
  };
}

class DatabaseClientImpl {
  #token;

  constructor(name, token) {
    this.name = name;
    this.#token = token;
  }
  async query(sql, params, {signal} = {}) {
    const queryUrl = new URL(&quot;/query&quot;, this.#token.url).toString();
    const response = await fetch(queryUrl, {
      method: &quot;POST&quot;,
      headers: {
        Authorization: `Bearer ${this.#token.token}`,
        &quot;Content-Type&quot;: &quot;application/json&quot;
      },
      body: JSON.stringify({sql, params}),
      signal
    });
    if (!response.ok) {
      if (response.status === 401) {
        throw new Error(&quot;Unauthorized: invalid or expired token. Try again?&quot;);
      }
      const contentType = response.headers.get(&quot;content-type&quot;);
      throw new Error(
        contentType &amp;&amp; contentType.startsWith(&quot;application/json&quot;)
          ? (await response.json()).message
          : await response.text()
      );
    }
    const {data, schema: jsonSchema} = await response.json();

    const schema = parseJsonSchema(jsonSchema);
    if (schema) {
      coerce(schema, data);
      Object.defineProperty(data, &quot;schema&quot;, {
        value: schema,
        writable: true
      });
    }

    return data;
  }

  queryTag(strings, ...args) {
    switch (this.type) {
      case &quot;oracle&quot;:
      case &quot;databricks&quot;:
        return [strings.reduce((prev, curr, i) =&gt; `${prev}:${i}${curr}`), args];
      case &quot;mysql&quot;:
        return [strings.reduce((prev, curr, i) =&gt; `${prev}@${i}${curr}`), args];
      case &quot;postgres&quot;:
        return [strings.reduce((prev, curr, i) =&gt; `${prev}$${i}${curr}`), args];
    }
    return [strings.join(&quot;?&quot;), args];
  }

  async sql() {
    return this.query(...this.queryTag.apply(this, arguments));
  }
}

function coerceBuffer(d) {
  return Uint8Array.from(d.data).buffer;
}

function coerceDate(d) {
  return new Date(d);
}

function coerceBigInt(d) {
  return BigInt(d);
}

function coercer(schema) {
  const mappings = schema
    .map(({name, type}) =&gt; {
      switch (type) {
        case &quot;buffer&quot;:
          return [name, coerceBuffer];
        case &quot;date&quot;:
          return [name, coerceDate];
        case &quot;bigint&quot;:
          return [name, coerceBigInt];
      }
    })
    .filter((d) =&gt; d);
  return (data) =&gt; {
    for (const [column, coerce] of mappings) {
      for (const row of data) {
        if (row[column] != null) {
          row[column] = coerce(row[column]);
        }
      }
    }
    return data;
  };
}

function coerce(schema, data) {
  return coercer(schema)(data);
}

// The data connector returns certain types as &quot;database types&quot; that we want to
// treat as (JavaScript) types.
function jsType(type, typeFlag) {
  if (
    (type === &quot;string&quot; &amp;&amp; typeFlag === &quot;date&quot;) ||
    (type === &quot;object&quot; &amp;&amp; typeFlag === &quot;buffer&quot;)
    // (type === &quot;string&quot; &amp;&amp; typeFlag === &quot;bigint&quot;) // TODO coerce bigints
  ) {
    return typeFlag;
  }
  return type;
}

function parseType(typeOptions) {
  let type;
  let nullable;
  if (Array.isArray(typeOptions)) {
    // type: [&quot;string&quot;] (not nullable)
    // type: [&quot;null&quot;, &quot;string&quot;] (nullable)
    type = typeOptions.find((t) =&gt; t !== &quot;null&quot;) ?? &quot;other&quot;;
    nullable = typeOptions.some((t) =&gt; t === &quot;null&quot;);
  } else {
    // type: &quot;string&quot; (not nullable)
    type = typeOptions;
    nullable = false;
  }
  return {type, nullable};
}

/**
 * This function parses a JSON schema object into an array of objects, matching
 * the &quot;column set schema&quot; structure defined in the DatabaseClient
 * specification. It does not support nested types (e.g. array element types,
 * object property types), but may do so in the future.
 * https://observablehq.com/@observablehq/database-client-specification
 *
 * For example, this JSON schema object:
 * {
 *   type: &quot;array&quot;,
 *   items: {
 *     type: &quot;object&quot;,
 *     properties: {
 *       TrackId: { type: &quot;integer&quot; },
 *       Name: { type: &quot;string&quot;, varchar: true },
 *       AlbumId: { type: &quot;number&quot;, long: true },
 *       GenreId: { type: &quot;array&quot; },
 *     }
 *   }
 * }
 *
 * will be parsed into this column set schema:
 *
 * [
 *   {name: &quot;TrackId&quot;, type: &quot;integer&quot;},
 *   {name: &quot;Name&quot;, type: &quot;string&quot;, databaseType: &quot;varchar&quot;},
 *   {name: &quot;AlbumId&quot;, type: &quot;number&quot;, databaseType: &quot;long&quot;},
 *   {name: &quot;GenreId&quot;, type: &quot;array&quot;}
 * ]
 */
function parseJsonSchema(schema) {
  if (schema?.type !== &quot;array&quot; || schema.items?.type !== &quot;object&quot; || schema.items.properties === undefined) {
    return [];
  }
  return Object.entries(schema.items.properties).map(([name, {type: typeOptions, ...rest}]) =&gt; {
    const {type, nullable} = parseType(typeOptions);
    let typeFlag;

    // The JSON Schema representation used by the data connector includes some
    // arbitrary additional boolean properties to indicate the database type,
    // such as {type: [&quot;null&quot;, &quot;string&quot;], date: true}. This code is a little
    // bit dangerous because the first of ANY exactly true property will be
    // considered the database type; for example, we must be careful to ignore
    // {type: &quot;object&quot;, properties: {}} and {type: &quot;array&quot;, items: {}}.
    for (const key in rest) {
      if (rest[key] === true) {
        typeFlag = key;
        break;
      }
    }

    return {
      name,
      type: jsType(type, typeFlag),
      nullable,
      ...(typeFlag &amp;&amp; {databaseType: typeFlag})
    };
  });
}
</pre><h4>client.js</h4>
        <pre>import {Runtime, Library, Inspector} from &quot;npm:@observablehq/runtime&quot;;

const library = Object.assign(new Library(), {width, Mutable, ...recommendedLibraries()});
const runtime = new Runtime(library);
const main = runtime.module();

const attachedFiles = new Map();
const resolveFile = (name) =&gt; attachedFiles.get(name);
main.builtin(&quot;FileAttachment&quot;, runtime.fileAttachments(resolveFile));

const databaseTokens = new Map();
async function resolveDatabaseToken(name) {
  const token = databaseTokens.get(name);
  if (!token) throw new Error(`Database configuration for ${name} not found`);
  return token;
}

const cellsById = new Map();
const Generators = library.Generators;

// Override the width definition to use main instead of body (and also use a
// ResizeObserver instead of listening for window resize events).
function width() {
  return Generators.observe((notify) =&gt; {
    let width;
    const observer = new ResizeObserver(([entry]) =&gt; {
      const w = entry.contentRect.width;
      if (w !== width) notify((width = w));
    });
    observer.observe(document.querySelector(&quot;main&quot;));
    return () =&gt; observer.disconnect();
  });
}

// Mutable returns a generator with a value getter/setting that allows the
// generated value to be mutated. Therefore, direct mutation is only allowed
// within the defining cell, but the cell can also export functions that allows
// other cells to mutate the value as desired.
function Mutable() {
  return function Mutable(value) {
    let change;
    return Object.defineProperty(
      Generators.observe((_) =&gt; {
        change = _;
        if (value !== undefined) change(value);
      }),
      &quot;value&quot;,
      {
        get: () =&gt; value,
        set: (x) =&gt; void change((value = x)) // eslint-disable-line no-setter-return
      }
    );
  };
}

// Override the common recommended libraries so that if a user imports them,
// they get the same version that the standard library provides (rather than
// loading the library twice). Also, its nice to avoid require!
function recommendedLibraries() {
  return {
    DatabaseClient: () =&gt; import(&quot;./database.js&quot;).then((db) =&gt; db.makeDatabaseClient(resolveDatabaseToken)),
    d3: () =&gt; import(&quot;npm:d3&quot;),
    htl: () =&gt; import(&quot;npm:htl&quot;),
    html: () =&gt; import(&quot;npm:htl&quot;).then((htl) =&gt; htl.html),
    svg: () =&gt; import(&quot;npm:htl&quot;).then((htl) =&gt; htl.svg),
    Plot: () =&gt; import(&quot;npm:@observablehq/plot&quot;),
    Inputs: () =&gt; {
      // TODO Observable Inputs needs to include the CSS in the dist folder
      // published to npm, and we should replace the __ns__ namespace with
      // oi-{hash} in the ES module distribution, somehow.
      const inputs = import(&quot;npm:@observablehq/inputs&quot;);
      const link = document.createElement(&quot;link&quot;);
      link.rel = &quot;stylesheet&quot;;
      link.href = &quot;https://cdn.jsdelivr.net/gh/observablehq/inputs/src/style.css&quot;;
      document.head.append(link);
      return inputs;
    }
  };
}

export function define(cell) {
  const {id, inline, inputs = [], outputs = [], files = [], databases = [], body} = cell;
  const variables = [];
  cellsById.get(id)?.variables.forEach((v) =&gt; v.delete());
  cellsById.set(id, {cell, variables});
  const root = document.querySelector(`#cell-${id}`);
  let reset = null;
  const clear = () =&gt; ((root.innerHTML = &quot;&quot;), (reset = null));
  const inspector = () =&gt; new Inspector(root.appendChild(document.createElement(&quot;SPAN&quot;)));
  const display = inline
    ? (v) =&gt; {
        reset?.();
        if (v instanceof Node || typeof v === &quot;string&quot; || !v?.[Symbol.iterator]) root.append(v);
        else root.append(...v);
        return v;
      }
    : (v) =&gt; {
        reset?.();
        inspector().fulfilled(v);
        return v;
      };
  const v = main.variable(
    {
      pending: () =&gt; (reset = clear),
      fulfilled: () =&gt; reset?.(),
      rejected: (error) =&gt; (reset?.(), inspector().rejected(error))
    },
    {
      shadow: {
        display: () =&gt; display,
        view: () =&gt; (v) =&gt; Generators.input(display(v))
      }
    }
  );
  v.define(outputs.length ? `cell ${id}` : null, inputs, body);
  variables.push(v);
  for (const o of outputs) variables.push(main.define(o, [`cell ${id}`], (exports) =&gt; exports[o]));
  for (const f of files) attachedFiles.set(f.name, {url: String(new URL(`/_file/${f.name}`, location)), mimeType: f.mimeType}); // prettier-ignore
  for (const d of databases) databaseTokens.set(d.name, d);
}

export function open({hash} = {}) {
  const socket = new WebSocket(Object.assign(new URL(&quot;/_observablehq&quot;, location.href), {protocol: &quot;ws&quot;}));

  socket.onopen = () =&gt; {
    console.info(&quot;socket open&quot;);
    send({type: &quot;hello&quot;, path: location.pathname, hash});
  };

  socket.onmessage = (event) =&gt; {
    const message = JSON.parse(event.data);
    console.info(&quot;&quot;, message);
    switch (message.type) {
      case &quot;reload&quot;: {
        location.reload();
        break;
      }
      case &quot;refresh&quot;:
        message.cellIds.forEach((id) =&gt; {
          const cell = cellsById.get(id);
          if (cell) define(cell.cell);
        });
        break;
      case &quot;update&quot;: {
        const root = document.querySelector(&quot;main&quot;);
        if (message.previousHash !== hash) {
          console.log(&quot;contents out of sync&quot;);
          location.reload();
          break;
        }
        hash = message.updatedHash;
        let offset = 0;
        for (const {type, oldPos, items} of message.diff) {
          switch (type) {
            case &quot;add&quot;: {
              for (const item of items) {
                switch (item.type) {
                  case &quot;html&quot;:
                    if (oldPos + offset &lt; root.children.length) {
                      root.children[oldPos + offset].insertAdjacentHTML(&quot;beforebegin&quot;, item.html);
                    } else {
                      root.insertAdjacentHTML(&quot;beforeend&quot;, item.html);
                    }
                    ++offset;
                    item.cellIds.forEach((id) =&gt; {
                      const cell = cellsById.get(id);
                      if (cell) define(cell.cell);
                    });
                    break;
                  case &quot;cell&quot;:
                    define({
                      id: item.id,
                      inline: item.inline,
                      inputs: item.inputs,
                      outputs: item.outputs,
                      databases: item.databases,
                      files: item.files,
                      body: (0, eval)(item.body)
                    });
                    break;
                }
              }
              break;
            }
            case &quot;remove&quot;: {
              let removes = 0;
              for (const item of items) {
                switch (item.type) {
                  case &quot;html&quot;:
                    if (oldPos + offset &lt; root.children.length) {
                      root.children[oldPos + offset].remove();
                      ++removes;
                    } else {
                      console.error(`remove out of range: ${oldPos + offset}  ${root.children.length}`);
                    }
                    break;
                  case &quot;cell&quot;:
                    cellsById.get(item.id)?.variables.forEach((v) =&gt; v.delete());
                    cellsById.delete(item.id);
                    break;
                }
              }
              offset -= removes;
              break;
            }
          }
        }
        break;
      }
    }
  };

  socket.onerror = (error) =&gt; {
    console.error(error);
  };

  socket.onclose = () =&gt; {
    console.info(&quot;socket close&quot;);
  };

  function send(message) {
    console.info(&quot;&quot;, message);
    socket.send(JSON.stringify(message));
  }
}

{
  const toggle = document.querySelector(&quot;#observablehq-sidebar-toggle&quot;);
  let indeterminate = toggle.indeterminate;
  toggle.onclick = () =&gt; {
    const matches = matchMedia(&quot;(min-width: calc(640px + 4rem + 0.5rem + 240px + 2rem))&quot;).matches;
    if (indeterminate) (toggle.checked = !matches), (indeterminate = false);
    else if (toggle.checked === matches) indeterminate = true;
    toggle.indeterminate = indeterminate;
    if (indeterminate) localStorage.removeItem(&quot;observablehq-sidebar&quot;);
    else localStorage.setItem(&quot;observablehq-sidebar&quot;, toggle.checked);
  };
  addEventListener(&quot;keypress&quot;, (event) =&gt; {
    if (event.key === &quot;b&quot; &amp;&amp; event.metaKey &amp;&amp; !event.ctrlKey) {
      toggle.click();
      event.preventDefault();
    }
  });
}
</pre><h3>package.json</h3>
        <pre>{
  &quot;name&quot;: &quot;@observablehq/cli&quot;,
  &quot;license&quot;: &quot;UNLICENSED&quot;,
  &quot;version&quot;: &quot;0.0.34&quot;,
  &quot;type&quot;: &quot;module&quot;,
  &quot;publishConfig&quot;: {
    &quot;registry&quot;: &quot;https://npm.pkg.github.com&quot;
  },
  &quot;repository&quot;: {
    &quot;type&quot;: &quot;git&quot;,
    &quot;url&quot;: &quot;https://github.com/observablehq/cli.git&quot;
  },
  &quot;files&quot;: [
    &quot;bin/**/*.js&quot;,
    &quot;bin/**/*.ts&quot;,
    &quot;src/**/*.js&quot;,
    &quot;src/**/*.ts&quot;,
    &quot;public/**/*.css&quot;,
    &quot;public/**/*.js&quot;
  ],
  &quot;bin&quot;: {
    &quot;observable&quot;: &quot;bin/observable.ts&quot;
  },
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;tsx watch ./src/preview.ts&quot;,
    &quot;build&quot;: &quot;rm -rf dist &amp;&amp; ./bin/observable.ts build&quot;,
    &quot;test&quot;: &quot;yarn test:mocha &amp;&amp; yarn test:lint&quot;,
    &quot;test:mocha&quot;: &quot;mkdir -p test/output &amp;&amp; tsx ./node_modules/.bin/mocha &apos;test/**/*-test.*&apos;&quot;,
    &quot;test:lint&quot;: &quot;eslint src test public&quot;
  },
  &quot;dependencies&quot;: {
    &quot;@observablehq/runtime&quot;: &quot;^5.9.4&quot;,
    &quot;acorn&quot;: &quot;^8.10.0&quot;,
    &quot;acorn-walk&quot;: &quot;^8.2.0&quot;,
    &quot;fast-array-diff&quot;: &quot;^1.1.0&quot;,
    &quot;fast-deep-equal&quot;: &quot;^3.1.3&quot;,
    &quot;gray-matter&quot;: &quot;^4.0.3&quot;,
    &quot;highlight.js&quot;: &quot;^11.8.0&quot;,
    &quot;linkedom&quot;: &quot;^0.15.6&quot;,
    &quot;markdown-it&quot;: &quot;^13.0.2&quot;,
    &quot;markdown-it-anchor&quot;: &quot;^8.6.7&quot;,
    &quot;mime&quot;: &quot;^3.0.0&quot;,
    &quot;send&quot;: &quot;^0.18.0&quot;,
    &quot;tsx&quot;: &quot;^3.13.0&quot;,
    &quot;ws&quot;: &quot;^8.14.2&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;@types/markdown-it&quot;: &quot;^13.0.2&quot;,
    &quot;@types/mime&quot;: &quot;^3.0.2&quot;,
    &quot;@types/mocha&quot;: &quot;^10.0.2&quot;,
    &quot;@types/node&quot;: &quot;^20.7.1&quot;,
    &quot;@types/send&quot;: &quot;^0.17.2&quot;,
    &quot;@types/ws&quot;: &quot;^8.5.6&quot;,
    &quot;@typescript-eslint/eslint-plugin&quot;: &quot;^6.7.3&quot;,
    &quot;@typescript-eslint/parser&quot;: &quot;^6.7.3&quot;,
    &quot;eslint&quot;: &quot;^8.50.0&quot;,
    &quot;eslint-config-prettier&quot;: &quot;^9.0.0&quot;,
    &quot;eslint-plugin-prettier&quot;: &quot;^5.0.0&quot;,
    &quot;mocha&quot;: &quot;^10.2.0&quot;,
    &quot;prettier&quot;: &quot;^3.0.3&quot;,
    &quot;typescript&quot;: &quot;^5.2.2&quot;
  },
  &quot;engines&quot;: {
    &quot;node&quot;: &quot;&gt;=18&quot;
  }
}
</pre><h2>docs</h2><h4>markdown.md</h4>
        <pre># Markdown reference

See [GitHubs guide to Markdown](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) for an introduction.

## JavaScript in Markdown

In addition to standard Markdown features  headings, formatting, tables, images, and the like  Observable Markdown supports [reactive JavaScript](./javascript) that runs on the client. Live JavaScript can be expressed either as [fenced code blocks](#fenced-code-blocks) (&lt;code&gt;```js&lt;/code&gt;) or [inline expressions](#inline-expressions) (&lt;code&gt;$\{}&lt;/code&gt;).

### Fenced code blocks

JavaScript fenced code blocks are typically used to display content such as charts and inputs. They can also declare top-level variables, say to load data or declare helper functions. An expression code block looks like this (note the lack of semicolon):

````md
```js
1 + 2
```
````

This produces:

```js
1 + 2
```

If the expression evaluates to a DOM node, the node is displayed. For example, here is an SVG element generated by [Observable Plot](https://observablehq.com/plot):

````md
```js
Plot.lineY(aapl, {x: &quot;Date&quot;, y: &quot;Close&quot;}).plot({y: {grid: true}})
```
````

This produces:

```js
Plot.lineY(aapl, {x: &quot;Date&quot;, y: &quot;Close&quot;}).plot({y: {grid: true}})
```

A program code block looks like this:

````md
```js
const x = 1 + 2;
```
````

```js
const x = 1 + 2;
```

A program code block doesnt display anything by default, but you can call the built-in [`display` function](./javascript#display(value)) explicitly. The above block defines the top-level variable `x` with a value of ${x}.

(A technical note: the parser first attempts to parse the input as an expression; if that fails, it parses it as a program. So, code such as `{foo: 1}` is interpreted as an object literal rather than a block with a labeled statement.)

### Inline expressions

Inline JavaScript expressions interpolate live values into Markdown. They are typically used to display dynamic numbers such as metrics, or to arrange visual elements such as charts into rich HTML layouts.

For example, this paragraph simulates rolling a 20-sided dice:

```md
You rolled ${Math.floor(Math.random() * 20) + 1}.
```

You rolled ${Math.floor(Math.random() * 20) + 1}. Reload the page to re-roll.

As with code blocks, if an inline expression evaluates to a DOM node, it will be displayed. For example, you can interpolate a sparkline ${Plot.plot({axis: null, margin: 0, width: 80, height: 17, x: {type: &quot;band&quot;, round: false}, marks: [Plot.barY(aapl.slice(-15), {x: &quot;Date&quot;, y1: 150, y2: &quot;Close&quot;, fill: &quot;steelblue&quot;})]})} or even a reactive input ${Inputs.bind(htl.html`&lt;input type=range style=&quot;width: 120px;&quot;&gt;`, numberInput)} ${number} into prose.

```js
const numberInput = Inputs.input(0);
const number = Generators.input(numberInput);
```

Unlike code blocks, expressions cannot declare top-level variables.

## HTML in Markdown

You can write HTML directly into Markdown. HTML is useful for greater control over layout, say to use CSS grid for a responsive bento box layout in a dashboard, or adding an external stylesheet via a link element. For example, here is an HTML details element:

````html
&lt;details&gt;
  &lt;summary&gt;Click me&lt;/summary&gt;
  This text is not visible by default.
&lt;/details&gt;
````

This produces:

&lt;details&gt;
  &lt;summary&gt;Click me&lt;/summary&gt;
  This text is not visible by default.
&lt;/details&gt;

In Markdown, blank lines denote separate HTML blocks; be sure to avoid blank lines if you want to treat a chunk of HTML as a single block. For example, write this:

```md
&lt;!--  one HTML block --&gt;
&lt;ul&gt;
  &lt;li&gt;one&lt;/li&gt;
  &lt;li&gt;two&lt;/li&gt;
  &lt;li&gt;three&lt;/li&gt;
&lt;/ul&gt;
```

Dont write this:

```md
&lt;!--  three HTML blocks --&gt;
&lt;ul&gt;

  &lt;li&gt;one&lt;/li&gt;
  &lt;li&gt;two&lt;/li&gt;
  &lt;li&gt;three&lt;/li&gt;

&lt;/ul&gt;
```

In the latter case, the li elements become top-level and wrapped in a span, rather than children of the ul.
</pre><h4>javascript.md</h4>
        <pre># JavaScript reference

[Observable Markdown](./markdown) supports reactive JavaScript. JavaScript runs on the client, powered by the [Observable Runtime](https://github.com/observablehq/runtime). (In the future, JavaScript may also run during build to support data snapshot generation and server-side rendering.)

## Reactivity

You may be accustomed to code running sequentially from top to bottom, and manually evaluating code in a notebook; Observable is different: we use [dataflow](https://en.wikipedia.org/wiki/Dataflow_programming), as in a spreadsheet, to *automatically* run code in topological order as determined by [top-level variable](#top-level-variables) references. For example, here we reference variables `x` and `y` even though they are defined in a code block below:

```js show
x + y
```

When code (such as `x + y`) references variables (such as `x` and `y`) defined by other code, the *referencing* code automatically runs after the *defining* code. Since code runs independently of its order on the page, giving you the flexibility to arrange your code however you like.

### Top-level variables

A top-level variable declared in a JavaScript fenced code block can be referenced in another code block or inline expression on the same page. So if you say:

```js show
const x = 1, y = 2;
```

Then you can reference `x` and `y` elsewhere on the page (with values ${x} and ${y}, respectively). Top-level variable declarations are effectively [hoisted](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting); you can reference variables even if the defining code block appears later on the page, and code runs in topological rather than top-down document order. If multiple blocks define top-level variables with the same name, references to these variables will throw a duplicate definition error.

To prevent variables from being visible outside the current block, make them local with a block statement:

```js show
{
  const z = 3;
}
```

### Promises

When code refers to a promise defined in another code block, the referencing code implicitly awaits the promise. Most often, promises are used to load files, fetch data from a remote server, or query a database. As a contrived example, within the block below, `hello` is a promise that resolves via `setTimeout`; if you reference `hello` from another code block or expression, the other code wont run until the timeout fires and will see `hello` as a string.

```js show
const hello = new Promise((resolve) =&gt; {
  setTimeout(() =&gt; {
    resolve(&quot;hello&quot;);
  }, 1000);
});
```

Hello is: ${hello}.

### Generators

When code refers to a [generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator) defined in another code block, the referencing code automatically runs each time the generator yields a value. Values that change over time, such as interactive inputs and animation parameters, are often represented as generators. For example, you can use [Observable Inputs](https://github.com/observablehq/inputs) and the built-in [`view` function](#view(input)) to construct a live text input. Try entering your name into the box below:

```js show
const name = view(Inputs.text({label: &quot;Name&quot;, placeholder: &quot;Enter your name&quot;}));
```

Name is: ${name}.

The `view` function calls `Generators.input` under the hood, which takes an input element and returns a generator that yields the inputs value whenever it changes. The code above can be written more explicitly as:

```js no-run
const nameInput = Inputs.text({label: &quot;Name&quot;, placeholder: &quot;Enter your name&quot;});
const name = Generators.input(nameInput);

display(nameInput);
```

As another example, you can use the built-in `Generators.observe` to represent the current pointer coordinates:

```js show
const pointer = Generators.observe((notify) =&gt; {
  const pointermoved = (event) =&gt; notify([event.clientX, event.clientY]);
  addEventListener(&quot;pointermove&quot;, pointermoved);
  notify([0, 0]);
  return () =&gt; removeEventListener(&quot;pointermove&quot;, pointermoved);
});
```

Pointer is: ${pointer.map(Math.round).join(&quot;, &quot;)}.

#### Mutable(*value*)

Normally, only the code block that declares a top-level variable can define it or assign to it. (This constraint may helpfully encourage you to decouple code.) You can however use the `Mutable` function to declare a mutable generator, allowing other code to mutate the generators value. This approach is akin to Reacts `useState` hook. For example:

```js show
const count = Mutable(0);
const increment = () =&gt; ++count.value;
const reset = () =&gt; count.value = 0;
```

In other code, you can now create buttons to increment and reset the count like so:

```js show
Inputs.button([[&quot;Increment&quot;, increment], [&quot;Reset&quot;, reset]])
```

&lt;style type=&quot;text/css&quot;&gt;
@keyframes flash {
  from { background-color: var(--theme-foreground-focus); }
  to { background-color: none; }
}
.flash {
  animation-name: flash;
  animation-duration: 1s;
}
&lt;/style&gt;

Count is: ${htl.html`&lt;span class=&quot;flash&quot;&gt;${count}&lt;/span&gt;`}.

Within the defining code block, `count` is a generator and `count.value` can be read and written to as desired; in other code, `count` is the generators current value. Other code that references `count` will re-run automatically whenever `count.value` is reassigned so be careful you dont cause an infinite loop!

## Displaying content

A JavaScript fenced code block containing an expression will automatically display its value, as will an inline JavaScript expression. You can also manually display elements or inspect values by calling the built-in `display` function.

### display(*value*)

If `value` is a DOM node, adds it to the DOM. Otherwise, converts the given `value` to a suitable DOM node and displays that instead. Returns the given `value`.

When `value` is not a DOM node, display will automatically create a suitable corresponding DOM node to display. The exact behavior depends on the input `value`, and whether display is called within a fenced code block or an inline expression. In fenced code blocks, display will use the [Observable Inspector](https://github.com/observablehq/inspector); in inline expressions, display will coerce non-DOM values to strings, and will concatenate values when passed an iterable.

You can call display multiple times within the same code block or inline expression to display multiple values. The display will be automatically cleared if the associated code block or inline expression is re-run.

### view(*input*)

As described above, this function displays the given `input` and then returns its corresponding generator via `Generators.input`. Use this to display an input element while also declaring the inputs current value as a reactive top-level variable.

## Imports

You can import a library from npm like so:

```js show
import confetti from &quot;npm:canvas-confetti&quot;;
```

Now you can reference the imported `confetti` anywhere on the page.

```js show
Inputs.button(&quot;Throw confetti!&quot;, {reduce: () =&gt; confetti()})
```

You can also import JavaScript from local ES modules. This allows you to move code out of Markdown and into vanilla JavaScript files that can be shared by multiple pages or even another application. And you can write tests for your code.

## Files

You can load files using the built-in `FileAttachment` function.

```js show
const gistemp = FileAttachment(&quot;gistemp.csv&quot;).csv({typed: true});
```

The following type-specific methods are supported: *csv*, *html*, *image*, *json*, *sqlite*, *text*, *tsv*, *xlsx*, *xml*, and *zip*. There are also generic methods: *arrayBuffer*, *blob*, and *url*. Each method returns a promise to the files contents (or URL).

We use static analysis to determine which files are used so that we can include only referenced files when building. The `FileAttachment` function accepts only literal strings; code such as `FileAttachment(&quot;my&quot; + &quot;file.csv&quot;)` or similar dynamic invocation is invalid syntax.
</pre><h4>index.md</h4>
        <pre>---
title: Overview
---

# Observable CLI

```js
const width = 640;
const height = 320;
const betterPastel = [&quot;#b0deff&quot;, &quot;#ffd19a&quot;, &quot;#fff8a6&quot;];
const padRadius = 2;
const center = {r: 125};
const random = d3.randomUniform.source(d3.randomLcg(42))(5, 20);
const circles = Array.from({length: 600}, (_, i) =&gt; ({r: random()}));

d3.packSiblings([center, ...circles]);

for (const c of circles) {
  c.x = Math.round(c.x - center.x);
  c.y = Math.round(c.y - center.y);
}

center.x = center.y = 0;

const svg = d3
  .create(&quot;svg&quot;)
  .attr(&quot;viewBox&quot;, `${-width / 2} ${-height / 2} ${width} ${height}`)
  .attr(&quot;style&quot;, &quot;width: 100%; height: auto; display: block;&quot;);

svg
  .selectAll()
  .data(circles)
  .join(&quot;circle&quot;)
  .attr(&quot;cx&quot;, (d) =&gt; d.x)
  .attr(&quot;cy&quot;, (d) =&gt; d.y)
  .attr(&quot;fill&quot;, (d, i) =&gt; betterPastel[i % 3])
  .attr(&quot;r&quot;, 0)
  .on(&quot;pointerenter&quot;, (event, d) =&gt;
    d3
      .select(event.currentTarget)
      .transition()
      .ease(d3.easeCircleOut)
      .attr(&quot;r&quot;, 0)
      .transition()
      .delay(5000)
      .attr(&quot;r&quot;, Math.max(1, d.r - padRadius))
  )
  .transition()
  .delay((d, i) =&gt; i * 3)
  .attr(&quot;r&quot;, (d) =&gt; Math.round(Math.max(1, d.r - padRadius)));

svg
  .append(&quot;path&quot;)
  .attr(&quot;transform&quot;, `scale(${(center.r - padRadius) / 12}) translate(-12,-12)`)
  .attr(&quot;fill&quot;, &quot;currentColor&quot;)
  .attr(
    &quot;d&quot;,
    &quot;M12.1450213,20.7196596 C11.0175263,20.7196596 10.0411956,20.4623004 9.216,19.9475745 C8.39080438,19.4328485 7.75761923,18.7343023 7.31642553,17.8519149 C6.87523184,16.9695275 6.55251166,16.0340475 6.34825532,15.0454468 C6.14399898,14.0568461 6.04187234,12.990644 6.04187234,11.8468085 C6.04187234,10.9971021 6.09497819,10.1841741 6.20119149,9.408 C6.30740479,8.63182591 6.50348793,7.84340826 6.78944681,7.0427234 C7.07540569,6.24203855 7.44306158,5.54757741 7.89242553,4.95931915 C8.34178948,4.37106089 8.93003892,3.89310822 9.65719149,3.52544681 C10.3843441,3.1577854 11.2136124,2.97395745 12.1450213,2.97395745 C13.2725163,2.97395745 14.2488469,3.23131658 15.0740426,3.74604255 C15.8992382,4.26076853 16.5324233,4.95931474 16.973617,5.84170213 C17.4148107,6.72408952 17.7375309,7.65956953 17.9417872,8.64817021 C18.1460436,9.6367709 18.2481702,10.702973 18.2481702,11.8468085 C18.2481702,12.6965149 18.1950644,13.5094429 18.0888511,14.285617 C17.9826378,15.0617911 17.7824696,15.8502088 17.4883404,16.6508936 C17.1942113,17.4515785 16.8265554,18.1460396 16.3853617,18.7342979 C15.944168,19.3225561 15.3600036,19.8005088 14.6328511,20.1681702 C13.9056985,20.5358316 13.0764302,20.7196596 12.1450213,20.7196596 Z M14.245196,13.9469832 C14.8285807,13.3635984 15.1202688,12.6635472 15.1202688,11.8468085 C15.1202688,11.0300698 14.8358729,10.3300186 14.2670728,9.74663382 C13.6982726,9.16324904 12.9909292,8.87156103 12.1450213,8.87156103 C11.2991134,8.87156103 10.5917699,9.16324904 10.0229698,9.74663382 C9.45416961,10.3300186 9.1697738,11.0300698 9.1697738,11.8468085 C9.1697738,12.6635472 9.45416961,13.3635984 10.0229698,13.9469832 C10.5917699,14.530368 11.2991134,14.822056 12.1450213,14.822056 C12.9909292,14.822056 13.6909804,14.530368 14.245196,13.9469832 Z M12,24 C18.627417,24 24,18.627417 24,12 C24,5.372583 18.627417,0 12,0 C5.372583,0 0,5.372583 0,12 C0,18.627417 5.372583,24 12,24 Z&quot;
  );

display(svg.node());
```

The **Observable command-line interface (CLI)** is a static site generator for creating beautiful notebooks, reports, and dashboards written in Markdown with reactive JavaScript. Use it to

- develop and preview pages locally; and
- build and host pages on any static file server, including GitHub Pages.

Current features:

- [Observable Markdown](./markdown)
- [Reactive JavaScript](./javascript), as both fenced code blocks and inline expressions
- Import from npm and local ES modules
- Local preview server with hot module replacement
- Static site generator
- File attachments
- Light and dark mode
- Navigation sidebar

In development:

- Table of contents sidebar
- Database queries
- Database query snapshots
- Data tables for interactive visual summaries of tabular data
- SQL code blocks
- Server-side fetch
- Server-side fetch snapshots
- Secrets (environment variables)
- ${tex`\TeX`} and Graphviz blocks
- Incremental reloading for file attachments
- Custom headers, footers, and themes

In the future, the Observable CLI will integrate seamlessly with the [Observable cloud platform](https://observablehq.com), making it easy for you to deploy and develop pages collaboratively with your team.
</pre><h4>contributing.md</h4>
        <pre># Contributing

If youd like to contribute to the Observable CLI, heres how. First clone the [git repo](https://github.com/observablehq/cli) and run [Yarn (1.x)](https://classic.yarnpkg.com/lang/en/docs/install/) to install dependencies:

```sh
git clone git@github.com:observablehq/cli.git
cd cli
yarn
```

Next start the local preview server:

```sh
yarn dev
```

Lastly visit &lt;http://127.0.0.1:3000&gt;.

The local preview server restarts automatically if you edit any of the TypeScript files, though you may need to reload. The default page is [docs/index.md](https://github.com/observablehq/cli/blob/main/docs/index.md?plain=1); if you edit that file and save changes, the live preview in the browser will automatically update.

To generate the static site:

```sh
yarn build
```

This creates the `dist` folder. View the site using your preferred web server, such as:

```sh
http-server dist
```

This documentation site is built on GitHub using the Observable CLI; see the [deploy workflow](https://github.com/observablehq/cli/blob/main/.github/workflows/deploy.yml). Please open a pull request if youd like to contribute to the documentation or to CLI features. Contributors are expected to follow our [code of conduct](https://github.com/observablehq/.github/blob/master/CODE_OF_CONDUCT.md). 

## Releasing

(Note: This documentation is for Observable maintainers.) To release a new version of the CLI, first update the [package.json](https://github.com/observablehq/cli/blob/main/package.json) file by following the standard process for committing code changes:

1. Create a new branch.
2. Edit the `version` field in the [package.json](https://github.com/observablehq/cli/blob/main/package.json) file as desired.
3. Commit your change to your branch.
4. Push your branch up to GitHub.
5. Open a pull request and ask for a review.
6. Once approved, merge your pull request to the `main` branch.

Once the above is done, you can publish the release via GitHub:

1. Go to [**Draft a new release**](https://github.com/observablehq/cli/releases/new).
2. Under **Choose a tag**, enter the new version with a `v` *e.g.* `v0.0.5`.
3. Click **Create new tag: v0.0.5**.
4. Leave the **Target** as `main`.
5. Click **Publish release**.

Thats it! The [publish action](https://github.com/observablehq/cli/actions/workflows/publish.yml) will take care of the rest.
</pre><h2>bin</h2><h4>observable.ts</h4>
        <pre>#!/usr/bin/env tsx

const command = process.argv.splice(2, 1)[0];

switch (command) {
  case &quot;-v&quot;:
  case &quot;--version&quot;: {
    import(&quot;../package.json&quot;).then(({version}: any) =&gt; console.log(version));
    break;
  }
  case &quot;build&quot;:
    import(&quot;../src/build.js&quot;);
    break;
  case &quot;preview&quot;:
    import(&quot;../src/preview.js&quot;);
    break;
  default:
    console.error(`Usage: observable &lt;command&gt;`);
    console.error(`   build\tgenerate a static site`);
    console.error(`   preview\trun the live preview server`);
    console.error(` --version\tprint the version`);
    process.exit(1);
    break;
}
</pre><h3>README.md</h3>
        <pre># Observable CLI

- [Documentation](https://cli.observablehq.com/)
- [Issues](https://github.com/observablehq/cli/issues)
</pre></body></html>